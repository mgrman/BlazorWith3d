@using BlazorWith3d.ExampleApp.Client.Shared
@using BlazorWith3d.Shared
@using BlazorWith3d.Unity
@using Microsoft.Extensions.Logging
@inject ILogger<BlocksOnGridUnityDebugRelay> Logger
@inject IJSRuntime JS
@implements IAsyncDisposable
@inject DebugRelayUnityApi DebugRelayUnityApi

<img @ref="_image"  draggable="false" style="width:100%; height: 100%; position: relative; pointer-events: none;  user-select: none;"/>
<script>
    window.setSource = async (element, stream, contentType, title) => {
        const arrayBuffer = await stream.arrayBuffer();
        let blobOptions = {};
        if (contentType) {
            blobOptions['type'] = contentType;
        }
        const blob = new Blob([arrayBuffer], blobOptions);
        const url = URL.createObjectURL(blob);
        element.title = title;
        element.onload = () => {
            URL.revokeObjectURL(url);
        }
        element.src = url;
    }
</script>
    
    @code{

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            if (!firstRender)
            {
                await base.OnAfterRenderAsync(firstRender);
                return;
            }

            DebugRelayUnityApi.ConnectedApi = DebugRelayUnityApiOnConnectedApi;
        
            await base.OnAfterRenderAsync(firstRender);
        }

        private async ValueTask DebugRelayUnityApiOnConnectedApi(DebugRelayUnityApi.BinaryApiForSocket? obj)
        {
           await InvokeAsync(async () =>
            {
                DebugRelayUnityApi.NewFrame -= UpdateFrame;
                UpdateFrame([]);
                StateHasChanged();

                if (obj != null)
                {
                    DebugRelayUnityApi.NewFrame += UpdateFrame;
                    var mainThreadApi = new BinaryApiThreadWrapper(obj, async t => await InvokeAsync(async () => await t()));
                    unityAppApi = new BlocksOnGrid3DRendererOverBinaryApi(new BinaryApiOverBinaryMessageApi(mainThreadApi), new MemoryPackBinaryApiSerializer(), new PoolingArrayBufferWriterFactory());
                    unityAppApi.OnMessageError += (o, e) =>
                    {
                        Logger.LogError(e, $"error handling message {string.Join(",", o)}");
                    };

                    var eventHandler = await ParentApp.AddRenderer(new BlocksOnGrid3DBlazorRenderer(unityAppApi, _image));
                    await unityAppApi.SetEventHandler(eventHandler);

                    // no need to notify that controller is ready, as the debug relay starts processing messages only after this handler finishes
                }
                else
                {
                    if (unityAppApi != null)
                    {
                        await ParentApp.RemoveRenderer(unityAppApi);
                    }
                }
            });
        }

    private BlocksOnGrid3DRendererOverBinaryApi? unityAppApi;

    [CascadingParameter] 
    public required IBlocksOnGrid3DBlazorController ParentApp { get; set; }

    private ElementReference _image;

    private bool _updatingImage;


    private async void UpdateFrame(byte[] obj)
    {
        if (_updatingImage)
        {
            return;
        }

        _updatingImage = true;
        try
        {
            await InvokeAsync(async () =>
            {
                using var imageStream = new MemoryStream(obj);
                var strRef = new DotNetStreamReference(imageStream);

                await JS.InvokeVoidAsync("setSource", _image, strRef, "image/jpg",
                    "frame");

                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex,"Error setting image");
        }
        finally
        {
            _updatingImage = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (unityAppApi != null)
        {
            await ParentApp.RemoveRenderer(unityAppApi);
        }
        DebugRelayUnityApi.ConnectedApi = null;
        DebugRelayUnityApi.NewFrame -= UpdateFrame;
        unityAppApi?.Dispose();
    }

}
@using BlazorWith3d.ExampleApp.Client.Shared
@using BlazorWith3d.Shared
@using BlazorWith3d.Shared.Blazor
@using BlazorWith3d.Unity
@using Microsoft.Extensions.Logging
@inject ILogger<BlocksOnGridUnityDebugRelay> Logger
@inject IJSRuntime JS
@implements IAsyncDisposable
@inject DebugRelayUnityApi DebugRelayUnityApi

<div  style="width: 500px; height: 500px; position: relative; border: red 1px solid; user-select: none">
    <img @ref="_image"  draggable="false" style="width:100%; height: 100%; position: relative; pointer-events: none;  user-select: none;"/>
</div>
<script>
    window.setSource = async (element, stream, contentType, title) => {
        const arrayBuffer = await stream.arrayBuffer();
        let blobOptions = {};
        if (contentType) {
            blobOptions['type'] = contentType;
        }
        const blob = new Blob([arrayBuffer], blobOptions);
        const url = URL.createObjectURL(blob);
        element.title = title;
        element.onload = () => {
            URL.revokeObjectURL(url);
        }
        element.src = url;
    }
</script>
    
    @code{

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            if (!firstRender)
            {
                await base.OnAfterRenderAsync(firstRender);
                return;
            }

            DebugRelayUnityApi.ConnectedApi = DebugRelayUnityApiOnConnectedApi;
        
            await base.OnAfterRenderAsync(firstRender);
        }

        private async ValueTask DebugRelayUnityApiOnConnectedApi(DebugRelayUnityApi.BinaryApiForSocket? obj)
        {
           await InvokeAsync(async () =>
            {
                DebugRelayUnityApi.NewFrame -= UpdateFrame;
                UpdateFrame([]);
                StateHasChanged();

                if (obj != null)
                {
                    DebugRelayUnityApi.NewFrame += UpdateFrame;
                    var mainThreadApi = new BinaryApiThreadWrapper(obj, async t => await InvokeAsync(async () => await t()));
                    var unityAppApi = new BlocksOnGrid3DRendererOverBinaryApi(new BinaryApiOverBinaryMessageApi(mainThreadApi), new BlazorJsonBinaryApiSerializer(), new PoolingArrayBufferWriterFactory(),ParentApp);
                    unityAppApi.OnMessageError += (o, e) =>
                    {
                        Logger.LogError(e, $"error handling message {string.Join(",", o)}");
                    };

                    _activeRenderer = new BlocksOnGridUnityDebugRelayRenderer(unityAppApi, _image);

                    await ParentApp.AddRenderer(_activeRenderer);
                }
                else
                {
                    if (_activeRenderer != null)
                    {
                        await ParentApp.RemoveRenderer(_activeRenderer);
                    }
                }
            });
        }
        
        
    private BlocksOnGridUnityDebugRelayRenderer? _activeRenderer;

    [CascadingParameter] 
    public required IBlocksOnGrid3DBlazorController ParentApp { get; set; }

    private ElementReference _image;

    private bool _updatingImage;


    private async void UpdateFrame(byte[] obj)
    {
        if (_updatingImage)
        {
            return;
        }

        _updatingImage = true;
        try
        {
            await InvokeAsync(async () =>
            {
                using var imageStream = new MemoryStream(obj);
                var strRef = new DotNetStreamReference(imageStream);

                await JS.InvokeVoidAsync("setSource", _image, strRef, "image/jpg",
                    "frame");

                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex,"Error setting image");
        }
        finally
        {
            _updatingImage = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_activeRenderer != null)
        {
            await ParentApp.RemoveRenderer(_activeRenderer);
        }
        DebugRelayUnityApi.ConnectedApi = null;
        DebugRelayUnityApi.NewFrame -= UpdateFrame;

        if (_activeRenderer?.RendererApi is IAsyncDisposable asyncDisposableApi)
        {
            await asyncDisposableApi.DisposeAsync();
        }
        else if (_activeRenderer?.RendererApi is IDisposable disposableApi)
        {
            disposableApi.Dispose();
        }
    }

    private record BlocksOnGridUnityDebugRelayRenderer(IBlocksOnGrid3DRenderer RendererApi, ElementReference RendererContainer)
        : IBlocksOnGrid3DBlazorRenderer;
}
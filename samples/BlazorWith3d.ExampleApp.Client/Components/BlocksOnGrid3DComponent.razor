@using System.Diagnostics
@using System.Diagnostics.CodeAnalysis
@using System.Numerics
@using Blazored.LocalStorage
@using BlazorWith3d.ExampleApp.Client.Shared
@using BlazorWith3d.Unity
@using BlazorWith3d.Shared
@using Microsoft.Extensions.Logging
@inject ILocalStorageService LocalStorage
@inject IServiceProvider Services
@inject ILogger<BlocksOnGrid3DComponent> Logger
@inject IJSRuntime JsRuntime
@implements I3DAppController
@implements IBlocksOnGrid3DApp_EventHandler
@implements IAsyncDisposable

<text>@(RendererInfo.Name) @(RendererInfo.IsInteractive?"Interactive":"Static")</text>


<table>
    <thead>
    <tr>
        <td>
            Template id
        </td>
        <td>
            sizeX
        </td>
        <td>
            sizeY
        </td>
        <td>
            sizeZ
        </td>
        <td>
            Visuals
        </td>
        <td>
        </td>
    </tr>
    </thead>
    @foreach (var template in _templates)
    {
        <tr>
            <td>
                @template.TemplateId
            </td>
            <td>
                @template.Size.X
            </td>
            <td>
                @template.Size.Y
            </td>
            <td>
                @template.Size.Z
            </td>
            <td>
                @template.VisualsUri
            </td>
            <td>
                <button @onclick="() => RemoveTemplate(template.TemplateId)">Remove</button>
            </td>
        </tr>
    }

    <tr>
        <td>

        </td>
        <td>
            <InputNumber @bind-Value="_newTemplateSizeX"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="_newTemplateSizeY"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="_newTemplateSizeZ"></InputNumber>
        </td>
        <td>
            <InputSelect @bind-Value="_newTemplateAsset">
                <option value="">None</option>
                @foreach (var (asset,index) in GltfAssets.Select((o,i)=>(o,i)))
                {
                    <option value="@index">@asset.name</option>
                }
            </InputSelect>
        </td>
        <td>
            <button @onclick="AddTemplate">Add</button>
        </td>
    </tr>
</table>


<table>
    <tr>
        <td>
            Block id
        </td>
        <td>
            positionX
        </td>
        <td>
            positionY
        </td>
        <td>
            rotationZ
        </td>
        <td>
            templateId
        </td>
        <td>
        </td>
    </tr>
    @foreach (var block in _instances)
    {
        <tr>
            <td>
                @block.BlockId
            </td>
            <td>
                @block.Position.X
            </td>
            <td>
                @block.Position.Y
            </td>
            <td>
                @block.RotationZ
            </td>
            <td>
                @block.TemplateId
            </td>
            <td>
                <button @onclick="() => RemoveBlock(block.BlockId)">Remove</button>
            </td>
        </tr>
    }

    <tr>
        <td>

        </td>
        <td>
            <InputNumber @bind-Value="_newBlockPositionX"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="_newBlockPositionY"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="_newBlockRotationZ"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="_newBlockTemplateId"></InputNumber>
        </td>
        <td>
            <button @onclick="AddBlock" disabled="@(!_templates.Any(o => o.TemplateId == _newBlockTemplateId))">Add</button>
        </td>
    </tr>
</table>

<button @onclick="PerfCheck">Perf Check</button>

<InputNumber @bind-Value="_perfTestCount"></InputNumber>
@if (!string.IsNullOrEmpty(_perfResponse))
{
    <div class="alert alert-warning alert-dismissible fade show" role="alert">
        @_perfResponse
    </div>
}

<div @ref="_rendererContainerReference" @onmousedown="OnMouseDown"  style="width: 500px; height: 500px; position: relative; border: red 1px solid">

    <CascadingValue Value="this" IsFixed="true">
        @ChildContent
    </CascadingValue>
</div>

@code {

    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    
    int _newIdCounter;

    float _newTemplateSizeX = 1;
    float _newTemplateSizeY = 1;
    float _newTemplateSizeZ = 1;
    int? _newTemplateAsset = null;

    float _newBlockPositionX;
    float _newBlockPositionY;
    float _newBlockRotationZ;
    int _newBlockTemplateId;

    string? _perfResponse;
    int _perfTestCount=100;

    private List<AddBlockTemplate> _templates = new();
    private List<AddBlockInstance> _instances = new();

    private IBlocksOnGrid3DApp? _rendererApi;
    private DotNetObjectReference<JsProxy>? _jsProxyReference;

    private int _requestIdCounter = 0;
    private Dictionary<int, TaskCompletionSource<RaycastResponse>> _activeRaycasts = new();
    private UnityAppInitialized _appState;
    private (AddBlockInstance instance, float offsetX,float offsetY)? _dragging;
    private IJSObjectReference module;
    private IJSObjectReference? _mouseEventsDispose;

    private ElementReference _rendererContainerReference;
    private Dictionary<int, TaskCompletionSource<ScreenToWorldRayResponse>>  _activeScreenToRay=new();

    private static (string name, string url )[] GltfAssets = [ ("BoomBox", "./_content/BlazorWith3d.ExampleApp.Client/gltf/BoomBox.glb")];
    

    protected override async Task OnInitializedAsync()
    {
        if (RendererInfo.Name== "Server")
        {
            await LoadInitialState();
        }

         _jsProxyReference = DotNetObjectReference.Create(new JsProxy(OnMouseMove, OnMouseUp));
        await base.OnInitializedAsync();
    }

    private async Task LoadInitialState()
    {
        _templates = await LocalStorage.GetItemAsync<List<AddBlockTemplate>>("_templates") ?? new List<AddBlockTemplate>();
        _instances = await LocalStorage.GetItemAsync<List<AddBlockInstance>>("_blocks") ?? new List<AddBlockInstance>();
        
        _newIdCounter = _templates.Select(o => o.TemplateId).Concat(_instances.Select(o => o.BlockId)).DefaultIfEmpty(-1).Max() + 1;
        
        StateHasChanged();
        await ReplayState();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }
        var moduleTask = new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.ExampleApp.Client/globalMouseEvents.js").AsTask());
        module = await moduleTask.Value;
        
        await LoadInitialState();
        await base.OnAfterRenderAsync(firstRender);
    }

    public void InitializeRenderer(IBlocksOnGrid3DApp? rendererApi)
    {
        if (_rendererApi != null)
        {
            _rendererApi.RemoveEventHandler(this);
        }
        
        _rendererApi = rendererApi;
        if (_rendererApi != null)
        {
            _rendererApi.SetUpUsingEventHandler(this);

            _rendererApi.InvokeBlazorControllerInitialized(new BlazorControllerInitialized());
        }
        
         ReplayState();
    }

    void IBlocksOnGrid3DApp_EventHandler.OnPerfCheck(PerfCheck msg)
    {
        // global OnPerfCheck handler is ignored, the event is handled at invocation as it is technical response
    }

     void IBlocksOnGrid3DApp_EventHandler.OnUnityAppInitialized(UnityAppInitialized msg)
    {
        _appState = msg;
    }

     void IBlocksOnGrid3DApp_EventHandler.OnScreenToWorldRayResponse(ScreenToWorldRayResponse obj)
    {
        _activeScreenToRay[obj.RequestId].SetResult(obj);
    }

     void IBlocksOnGrid3DApp_EventHandler.OnRaycastResponse(RaycastResponse obj)
    {
        _activeRaycasts[obj.RequestId].SetResult(obj);
    }

    private async ValueTask ReplayState()
    {
        if (_rendererApi == null)
        {
            return;
        }
        
        foreach (var template in _templates)
        {
            await _rendererApi.InvokeAddBlockTemplate(template);
        }

        foreach (var block in _instances)
        {
            await _rendererApi.InvokeAddBlockInstance(block);
        }
    }

    private async Task AddTemplate()
    {
        var msg = new AddBlockTemplate { TemplateId = _newIdCounter++, Size = new Vector3(_newTemplateSizeX, _newTemplateSizeY, _newTemplateSizeZ), VisualsUri = _newTemplateAsset==null?null:GltfAssets[_newTemplateAsset.Value].url};
        _templates.Add(msg);
        SaveToLocalStorage();
        
        if (_rendererApi != null)
        {
            await _rendererApi.InvokeAddBlockTemplate(msg);
        }
    }

    private void  SaveToLocalStorage()
    {
        Task.Run(async () =>
        {
            await LocalStorage.SetItemAsync("_templates", _templates);
            await LocalStorage.SetItemAsync("_blocks", _instances);
        });
    }

    private async Task RemoveTemplate(int id)
    {
        _templates.RemoveAll(o => o.TemplateId == id);
        SaveToLocalStorage();
        
        if (_rendererApi != null)
        {
            await _rendererApi.InvokeRemoveBlockTemplate(new RemoveBlockTemplate { TemplateId = id });
        }
    }

    private async Task AddBlock()
    {
        var msg = new AddBlockInstance { BlockId = _newIdCounter++, Position = new Vector2(_newBlockPositionX,_newBlockPositionY) , RotationZ = _newBlockRotationZ, TemplateId = _newBlockTemplateId };
        _instances.Add(msg);
        SaveToLocalStorage();
        
        if (_rendererApi != null)
        {
            await _rendererApi.InvokeAddBlockInstance(msg);
        }
    }

    private async Task RemoveBlock(int id)
    {
        _instances.RemoveAll(o => o.BlockId == id);
        SaveToLocalStorage();
        if (_rendererApi != null)
        {
            await _rendererApi.InvokeRemoveBlockInstance(new RemoveBlockInstance { BlockId = id });
        }
    }

    private async Task PerfCheck()
    {
        if (_rendererApi == null)
        {
            _perfResponse = "No Renderer is configured!";
            return;
        } 
        var testCount = _perfTestCount;

        var responses = new bool[testCount];
        var responsesRemaining = testCount;

        var tcs = new TaskCompletionSource();
        var avgStopwatch = new Stopwatch();

        _rendererApi.OnPerfCheck += Process;

        avgStopwatch.Start();
        for (var i = 0; i < testCount; i++)
        {
            await _rendererApi.InvokePerfCheck(new PerfCheck
            {
                Id = i,
                Aaa = 12,
                Bbb = 12.12,
                Ccc = 13888888888888,
                Ddd = "https://aaaa.cc/erekwn/sdas?adsasd=asda"
            });
        }

        await tcs.Task;

        _rendererApi.OnPerfCheck -= Process;

        _perfResponse = $"{testCount} messages there and back, took {avgStopwatch.ElapsedMilliseconds:F2} ms (avg {(decimal)avgStopwatch.ElapsedMilliseconds / testCount:F2} ms)";

        void Process(PerfCheck response)
        {
            responses[response.Id] = true;
            responsesRemaining--;
            if (responsesRemaining == 0)
            {
                avgStopwatch.Stop();
                tcs.SetResult();
            }
        }
    }

    private class JSVector2
    {
        public float X { get; set; }
        
        public float Y{ get; set; }
    }
    
    private async Task OnMouseDown( MouseEventArgs e)
    {
       var offset= await module.InvokeAsync<JSVector2>("ConvertPageToOffset", _rendererContainerReference, e.PageX, e.PageY);
        var rayOrigin = new Vector3((float)offset.X,(float) offset.Y, 0);

        
        var screenToRayId = _requestIdCounter++;
        var tcs1=new TaskCompletionSource<ScreenToWorldRayResponse>();
        _activeScreenToRay[screenToRayId] = tcs1;

        await _rendererApi.InvokeRequestScreenToWorldRay(new RequestScreenToWorldRay()
        {
            RequestId = screenToRayId,
            Screen = new Vector2(offset.X,offset.Y)
        });
        var screenToRayResponse=await tcs1.Task;
        
        
        var raycastId = _requestIdCounter++;

        var tcs=new TaskCompletionSource<RaycastResponse>();
        _activeRaycasts[raycastId] = tcs;

        await _rendererApi.InvokeRequestRaycast(new RequestRaycast()
        {
            RequestId = raycastId,
            Ray = screenToRayResponse.Ray
        });
        var raycastResponse=await tcs.Task;

        //#error raycast is somehow not hitting anything in unity!!!
        
        if (!raycastResponse.HitBlockId.HasValue)
        {
            return;
        }

        var instance = _instances.FirstOrDefault(o => o.BlockId == raycastResponse.HitBlockId);
        
        var offsetX =raycastResponse.HitWorld.X - instance.Position.X;
        var offsetY =  raycastResponse.HitWorld.Y - instance.Position.Y;
         _dragging = (instance,offsetX,offsetY);
         
         _mouseEventsDispose = await module.InvokeAsync<IJSObjectReference>("InitializeGlobalMouseEvents", _rendererContainerReference, _jsProxyReference, nameof(JsProxy.OnMouseMove), nameof(JsProxy.OnMouseUp));
    }
    
    private async void OnMouseMove(float offsetX, float offsetY)
    {
        if (!_dragging.HasValue)
        {
            return;
        }
        
        var dragging = _dragging.Value;
        
        
        var screenToRayId = _requestIdCounter++;
        var tcs1=new TaskCompletionSource<ScreenToWorldRayResponse>();
        _activeScreenToRay[screenToRayId] = tcs1;

        await _rendererApi.InvokeRequestScreenToWorldRay(new RequestScreenToWorldRay()
        {
            RequestId = screenToRayId,
            Screen = new Vector2(offsetX,offsetY)
        });
        var screenToRayResponse=await tcs1.Task;


        
        // TODO make configurable
        var worldToPlane = Matrix4x4.Identity; // as this defines the drag plane

        var rayOrigin = screenToRayResponse.Ray.Origin.ToVector3();
        var rayDirection = screenToRayResponse.Ray.Direction.ToVector3();

        rayOrigin=Vector3.Transform(rayOrigin,worldToPlane);
        rayDirection=Vector3.TransformNormal(rayDirection,worldToPlane);
        
        
        var plane = new Plane(new Vector3(0, 0, 1), 0);
        var potentialHit= plane.Raycast(new Ray(rayOrigin, rayDirection));
        if (potentialHit == null)
        {
            throw new InvalidOperationException();
        }

        var hit = potentialHit.Value;
        
        var newPositionX = hit.X - dragging.offsetX;
        var newPositionY = hit.Y - dragging.offsetY;


        newPositionY = (float)Math.Round(newPositionY, 0);


        dragging.instance.Position = new Vector2(newPositionX, newPositionY);
        
        _rendererApi.InvokeUpdateBlockInstance(new UpdateBlockInstance()
        {
            BlockId = dragging.instance.BlockId,
            Position= new Vector2(newPositionX,newPositionY),
            RotationZ= dragging.instance.RotationZ,
        });
        StateHasChanged();
    }
    
    private void OnMouseUp()
    {
        if (!_dragging.HasValue)
        {
            return;
        }
        
        _dragging = null;
        
        _mouseEventsDispose?.InvokeVoidAsync("Dispose");
    }

    private class JsProxy(Action<float,float> onMouseMove,Action onMouseUp)
    {
        [JSInvokable]
        public void OnMouseMove(float screenX, float screenY)
        {
            onMouseMove(screenX,screenY);
        }
        [JSInvokable]
        public void OnMouseUp()
        {
            onMouseUp();
        }
    }

    public ValueTask DisposeAsync()
    {
        _jsProxyReference?.Dispose();
        return ValueTask.CompletedTask;
    }

}
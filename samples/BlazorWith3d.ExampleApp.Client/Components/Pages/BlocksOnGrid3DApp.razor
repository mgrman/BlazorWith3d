@page "/app"
@using BlazorWith3d.ExampleApp.Client.Babylon
@using BlazorWith3d.ExampleApp.Client.Components
@using BlazorWith3d.ExampleApp.Client.Unity.Components
@using BlazorWith3d.ExampleApp.Client.HTML
@using BlazorWith3d.ExampleApp.Client.ThreeJS
@inject IFlagProvider  FlagProvider

<PageTitle>BlazorWith3D - Blocks on grid sample app</PageTitle>

<h1>Blocks on grid sample app</h1>

<div class="alert alert-light" role="alert">
    @switch (RendererInfo.Name)
    {
        case "WebView":
            <text> Running in Webview, using webview JS interop for communication. Expected good Blazor performance. </text>
            break;
        case "Server":
            <text> Running on the server and communicating with browser via Websocket. Expected slower Blazor performance due to network delays and slow VM the demo app is running on. </text>
            break;
        case "WebAssembly":
            <text> Running in WebAssembly, using WASM interop with JS. Expected good Blazor performance but slower cold loading times. </text>
            break;
        case "Static":
            <text> Loading ...</text>
            break;
        default:
            <text> Running in @RendererInfo.Name mode</text>
            break;
    }
</div>


@foreach (var renderer in _renderers)
{
    <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox"  checked="@renderer.IsSelected" @oninput="@(e=>renderer.IsSelected=!renderer.IsSelected)" disabled="@(!RendererInfo.IsInteractive)">
        <label class="form-check-label" >@renderer.Label</label>
    </div>
}

<BlocksOnGrid3DComponent>

    @foreach (var renderer in _renderers.Where(o => o.IsSelected).Select(o => o.Label))
    {
        @switch (renderer)
        {
            case "Unity WebGPU (using MemoryPack over BinaryAPI)":
                <BlocksOnGridUnityRenderer></BlocksOnGridUnityRenderer>
                // use binary api with response
                break;
            case "Unity WebGPU (using JSON over BinaryAPI)":
                if (_renderers.Where(o => o.IsSelected).Select(o => o.Label).Contains("Unity WebGPU"))
                {
                    <text> Unity WebGPU (JSON) cannot be used while another Unity WebGPU is active</text>
                }
                else
                {
                    <BlocksOnGridUnityRenderer UseJsonSerializer="true"></BlocksOnGridUnityRenderer>
                }

                // use binary api with response
                break;
            case "Html":
                <BlocksOnGridHTMLComponent></BlocksOnGridHTMLComponent>
                // implements the interface directly
                break;
            case "Babylon (using native JSON interop)":
                <BlocksOnGridBabylonDirectRenderer></BlocksOnGridBabylonDirectRenderer>
                // uses binary TS interface with response
                break;
            case "ThreeJS (using MemoryPack over BinaryAPI)":
                <BlocksOnGridThreeJSRenderer></BlocksOnGridThreeJSRenderer>
                // uses binary TS interface with response
                break;
            case "Unity Editor Debug Relay":
                <BlocksOnGridUnityDebugRelay ></BlocksOnGridUnityDebugRelay>
                // uses generated interop code 
                break;
            default:
                <text> Unsupported renderer type @renderer</text>
                break;
        }
    }

</BlocksOnGrid3DComponent>


@code{

    List<Selection> _renderers ;

    protected override void OnInitialized()
    {
        _renderers = new []{ "Unity WebGPU (using MemoryPack over BinaryAPI)","Unity WebGPU (using JSON over BinaryAPI)", "Html", "Babylon (using native JSON interop)", "ThreeJS (using MemoryPack over BinaryAPI)"}.Select(o=>new Selection(o)).ToList();
        if (FlagProvider.IsUnityRelayEnabled)
        {
            _renderers.Add(new Selection("Unity Editor Debug Relay"));
        }
        base.OnInitialized();
    }

    private class Selection
    {
        public Selection(string label)
        {
            Label = label;
            IsSelected = false;
        }

        public string Label { get; }
        
        public bool IsSelected { get; set; }
    }

}

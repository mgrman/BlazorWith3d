@rendermode InteractiveAuto
@using BlazorWith3d.ExampleApp.Client.Unity.Shared
@using BlazorWith3d.Unity
@using BlazorWith3d.Unity.Shared

@inject IServiceProvider Services

<InputCheckbox @bind-Value="Is3DVisible" ></InputCheckbox>

<text>@(OperatingSystem.IsBrowser()?"WASM":"Serverside")</text>


<table>
    <thead>
    <tr>
        <td>
            Template id
        </td>
        <td>
            sizeX
        </td>
        <td>
            sizeY
        </td>
        <td>
            sizeZ
        </td>
        <td>
        </td>
    </tr>
    </thead>
    @foreach (var template in _templates)
    {
        <tr>
            <td>
                @template.id
            </td>
            <td>
                @template.sizeX
            </td>
            <td>
                @template.sizeY
            </td>
            <td>
                @template.sizeZ
            </td>
            <td>
                <button @onclick="() => RemoveTemplate(template.id)">Remove</button>
            </td>
        </tr>
    }

    <tr>
        <td>

        </td>
        <td>
            <InputNumber @bind-Value="newTemplateSizeX"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="newTemplateSizeY"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="newTemplateSizeZ"></InputNumber>
        </td>
        <td>
            <button @onclick="AddTemplate">Add</button>
        </td>
    </tr>
</table>


<table>
    <tr>
        <td>
            Block id
        </td>
        <td>
            positionX
        </td>
        <td>
            positionY
        </td>
        <td>
            rotationZ
        </td>
        <td>
            templateId
        </td>
        <td>
        </td>
    </tr>
    @foreach (var block in _blocks)
    {
    <tr>
        <td>
            @block.blockId
        </td>
        <td>
            @block.positionX
        </td>
        <td>
            @block.positionY
        </td>
        <td>
            @block.rotationZ
        </td>
        <td>
            @block.templateId
        </td>
        <td>
            <button @onclick="()=> RemoveBlock(block.blockId)">Remove</button>
        </td>
    </tr>
    }

    <tr>
        <td>

        </td>
        <td>
            <InputNumber @bind-Value="newBlockPositionX"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="newBlockPositionY"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="newBlockRotationZ"></InputNumber>
        </td>
        <td>
            <InputNumber @bind-Value="newBlockTemplateId"></InputNumber>
        </td>
        <td>
            <button @onclick="AddBlock" disabled="@(!_templates.Any(o=>o.id==newBlockTemplateId))">Add</button>
        </td>
    </tr>
</table>


@if (Is3DVisible)
{
    <TypedMessageUnityComponent @ref="_unityComponent" UnityBuildFilePath="@Assets[""]"></TypedMessageUnityComponent>
}

@code {
    
    // TODO this is never null, test again how the disappearance is handled!!
    private TypedMessageUnityComponent? _unityComponent;
    private TypedMessageUnityComponent? _unityComponent2;
    private TypedMessageUnityComponent? _unityComponent23;
    private TypedMessageUnityComponent? _unityComponent233;

    private bool AppInitialized;
    
    int newIdCounter;
    
    float newTemplateSizeX=1;
    float newTemplateSizeY=1;
    float newTemplateSizeZ=1;
    
    float newBlockPositionX;
    float newBlockPositionY;
    float newBlockRotationZ;
    int newBlockTemplateId;

    private List<(int id, float sizeX, float sizeY, float sizeZ)> _templates = new();
    private List<(int blockId, float positionX, float positionY, float rotationZ, int templateId)> _blocks = new ();
    
    private bool _is3DVisible=true;
    public bool Is3DVisible
    {
        get => _is3DVisible;
        set
        {
            _is3DVisible = value;
            if (!value)
            {
                AppInitialized = false;
            }
        } 
    }

    protected override void OnInitialized()
    {
        
        base.OnInitialized();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        _unityComponent.AddMessageProcessCallback<AppInitialized>(OnAppInitialized);
        _unityComponent.AddMessageWithResponseProcessCallback<BlockPoseChangingMessage,PoseChangeResponse>(OnBlockPoseChanging);
        _unityComponent.AddMessageProcessCallback<BlockPoseChangedMessage>(OnBlockPoseChanged);
        base.OnAfterRender(firstRender);
    }

    private void OnBlockPoseChanged(BlockPoseChangedMessage obj)
    {
        var blockIndex = _blocks.FindIndex(o => o.blockId == obj.BlockId);
        var block = _blocks[blockIndex];

        _blocks[blockIndex] = (block.blockId, obj.PositionX, obj.PositionY, obj.RotationZ, block.templateId);
        this.StateHasChanged();
    }

    private async ValueTask<PoseChangeResponse> OnBlockPoseChanging(BlockPoseChangingMessage arg)
    {
        return new PoseChangeResponse()
        {
            IsValid = true,
            NewPositionX = (float)Math.Round(arg.PositionX,1),
            NewPositionY = (float)Math.Round(arg.PositionY,1),
            NewRotationZ = arg.RotationZ
        };
    }

    private async void  OnAppInitialized(AppInitialized arg)
    {
        AppInitialized = true;
        
       await ReplayState();
    }

    private async ValueTask ReplayState()
    {
        foreach (var template in _templates)
        {
            var msg = new AddBlockTemplateMessage() { TemplateId = template.id, SizeX = template.sizeX, SizeY = template.sizeY, SizeZ = template.sizeZ };
           await SendMessage(msg);
        }
        foreach (var block in _blocks)
        {
            var msg = new AddBlockInstanceMessage() { BlockId = block.blockId, PositionX = block.positionX, PositionY = block.positionY, RotationZ = block.rotationZ, TemplateId = block.templateId};
            SendMessage(msg);
        }
    }

    private async Task AddTemplate()
    {
        var msg = new AddBlockTemplateMessage() { TemplateId = newIdCounter++, SizeX = newTemplateSizeX, SizeY = newTemplateSizeY, SizeZ = newTemplateSizeZ };
        await SendMessage(msg);
        _templates.Add((msg.TemplateId, msg.SizeX, msg.SizeY, msg.SizeZ));
    }

    private async Task RemoveTemplate(int id)
    {
        await SendMessage(new RemoveBlockTemplateMessage(){ TemplateId = id});
        _templates.RemoveAll(o => o.id == id);
    }

    private async Task AddBlock()
    {
        var msg = new AddBlockInstanceMessage() { BlockId = newIdCounter++, PositionX = newBlockPositionX, PositionY = newBlockPositionY, RotationZ = newBlockRotationZ, TemplateId = newBlockTemplateId};
        await SendMessage(msg);
        _blocks.Add((msg.BlockId, msg.PositionX,msg.PositionY,msg.RotationZ, msg.TemplateId));
    }

    private async Task RemoveBlock(int id)
    {
        await SendMessage(new RemoveBlockMessage(){ BlockId = id});
        _blocks.RemoveAll(o => o.blockId == id);
    }

    private Task<TResponse> SendMessageWithResponse<TMessage, TResponse>(TMessage message) where TMessage : IMessageToUnity<TMessage, TResponse>
    {
        if (!AppInitialized)
        {
            throw new InvalidOperationException("Unity app is not initialized!");
        }
        return  _unityComponent.SendMessageWithResponse<TMessage, TResponse>(message);
    }

    private ValueTask SendMessage<TMessage>(TMessage message) where TMessage : IMessageToUnity<TMessage>
    {
        if (!AppInitialized)
        {
            throw new InvalidOperationException("Unity app is not initialized!");
        }
        
        return  _unityComponent.SendMessage<TMessage>(message);
    }

}
@using BlazorWith3d.Unity.Shared
@using Microsoft.JSInterop
@inject IJSRuntime JsRuntime
@inject ILogger<BaseBabylonRenderer> Logger
@implements BlazorWith3d.Unity.Shared.IBinaryApi
@using Microsoft.Extensions.Logging
@implements IAsyncDisposable

<canvas @ref="_containerElementReference" class="my-component"  width="960" height="600" tabindex="-1">
    This component is defined in the <strong>BlazorWith3d.ExampleApp.Client.Babylon</strong> library.
</canvas>


@code{

    private ElementReference _containerElementReference;
    private IJSObjectReference? module;
    private IJSObjectReference? _babylonApp;
    
    public virtual string BabylonAppPath => "";
    
    private DotNetObjectReference<JsMessageReceiverProxy>? _messageReceiverProxyReference;
    private readonly List<byte[]> _unsentMessages = new();
    private readonly ReceiveMessageBuffer _receiveMessageBuffer = new();

    public async ValueTask DisposeAsync()
    {
        if (_babylonApp != null)
        {
            await _babylonApp.InvokeVoidAsync("Quit");
            await _babylonApp.DisposeAsync();
            _babylonApp = null;
        }

        _messageReceiverProxyReference?.Dispose();
    }

    protected override void OnInitialized()
    {
        _messageReceiverProxyReference = DotNetObjectReference.Create(new JsMessageReceiverProxy(OnMessageBytesReceived));
        base.OnInitialized();
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }

        if (string.IsNullOrEmpty(BabylonAppPath))
        {
            throw new InvalidOperationException("BabylonAppPath is not overriden!");
        }


        var moduleTask = new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync
        <IJSObjectReference>
            ("import", BabylonAppPath).AsTask());
        
        module = await moduleTask.Value;
        
        
        _babylonApp = await module.InvokeAsync<IJSObjectReference>("InitializeBabylonApp", _containerElementReference,_messageReceiverProxyReference,nameof(JsMessageReceiverProxy.OnMessageBytesReceived) );

        foreach (var msg in _unsentMessages)
        {
            await SendMessage(msg);
        }

        _unsentMessages.Clear();

        await base.OnAfterRenderAsync(firstRender);
    }
    
    public Action<byte[]>? MainMessageHandler
    {
        get => _receiveMessageBuffer.MainMessageHandler;
        set => _receiveMessageBuffer.MainMessageHandler = value;
    }

    private void OnMessageBytesReceived(byte[] messageBytes)
    {
        _receiveMessageBuffer.InvokeMessage(messageBytes);
    }
    
    public async ValueTask SendMessage(byte[] messageBytes)
    {
        if (_babylonApp == null)
        {
            _unsentMessages.Add(messageBytes);
            return;
        }

        try
        {
            await _babylonApp.InvokeVoidAsync("ProcessMessage", messageBytes);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error sending message");
        }
    }
    
    private class JsMessageReceiverProxy(Action<byte[]> onMessageBytesReceived)
    {
        [JSInvokable]
        public void OnMessageBytesReceived(byte[] msg)
        {
            onMessageBytesReceived(msg);
        }
    }
}

           
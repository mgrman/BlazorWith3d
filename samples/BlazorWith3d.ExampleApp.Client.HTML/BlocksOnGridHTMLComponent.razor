@using System.Drawing
@using System.Globalization
@using System.Numerics
@using BlazorWith3d.ExampleApp.Client.Shared
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@implements IBlocksOnGrid3DApp
@inject ILogger<BlocksOnGridHTMLComponent> Logger
@inject IJSRuntime JsRuntime

<div @ref=_rendererContainerReference class="my-component" style="width:100%; height: 100%; position: relative">

    @if (_instances.Count > 0)
    {
        var minHeight = _templates.Values.Select(o => o.Size.Z).Min();
        var maxHeight = _templates.Values.Select(o => o.Size.Z).Max();
        var heightRange = maxHeight - minHeight;

        foreach(var(instance, template) in _instances.Select(instance => (instance, template: _templates[instance.TemplateId])))
        {
            var brightness = (byte)(((template.Size.Y - minHeight) / heightRange) * 255);
            var color = ColorTranslator.ToHtml(Color.FromArgb(brightness, 0, 0));
            <div class="my-component" 
            style="user-select: none; position: absolute; width: @ToStringCSS((template.Size.X)*scale)px; height: @ToStringCSS((template.Size.Y)*scale)px; background-color: @color; left: @ToStringCSS((instance.Position.X-template.Size.X/2+offsetX)*scale)px; top: @ToStringCSS((instance.Position.Y-template.Size.Y/2+offsetY)*scale)px; rotate: @ToStringCSS(instance.RotationZ)deg;"
            >
                @instance.BlockId
            </div>
        }
    }

</div>

@code
{

    private  float canvasSizeX ;
    private  float canvasSizeY ;

    private string ToStringCSS(float val) => val.ToString(CultureInfo.InvariantCulture);
    private float scale;
    private  float offsetX ;
    private  float offsetY ;

    private readonly Dictionary<int,AddBlockTemplate> _templates = new ();
    private readonly List<AddBlockInstance> _instances = new();
    private ElementReference _rendererContainerReference;

    private IJSObjectReference jsInteropModule;

    [CascadingParameter] 
    public required I3DAppController ParentApp { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }

        jsInteropModule = await new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.ExampleApp.Client.HTML/jsInterop.js").AsTask()).Value;

        ParentApp.InitializeRenderer(this);

        var bounds = await GetBoundingClientRect(_rendererContainerReference);

        var desiredCanvasSize = 10f;

        scale = Math.Min(bounds.Width / desiredCanvasSize, bounds.Height / desiredCanvasSize);

        canvasSizeX = bounds.Width / scale;
        canvasSizeY = bounds.Height / scale;

        offsetX = canvasSizeX / 2;
        offsetY = canvasSizeY / 2;

        OnUnityAppInitialized?.Invoke(new UnityAppInitialized()
        {

        });
        StateHasChanged();

        await base.OnAfterRenderAsync(firstRender);
    }

    private async ValueTask<RectangleF> GetBoundingClientRect(ElementReference elementReference)
    {
        return await jsInteropModule.InvokeAsync<RectangleF>("getBoundingClientRect", elementReference);
    }


    public event Action<byte[], Exception>? OnMessageError;
    public event Action<PerfCheck>? OnPerfCheck;
    public event Action<UnityAppInitialized>? OnUnityAppInitialized;
    public event Action<RaycastResponse>? OnRaycastResponse;



    public ValueTask InvokeBlazorControllerInitialized(BlazorControllerInitialized msg)
    {
        Logger.LogInformation("BlazorControllerInitialized");
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokePerfCheck(PerfCheck msg)
    {
        OnPerfCheck?.Invoke(msg);
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeAddBlockTemplate(AddBlockTemplate msg)
    {
        _templates[msg.TemplateId] = msg;
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeAddBlockInstance(AddBlockInstance msg)
    {
        _instances.Add(msg);
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRemoveBlockInstance(RemoveBlockInstance msg)
    {
        _instances.RemoveAll(o=>o.BlockId== msg.BlockId);
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRemoveBlockTemplate(RemoveBlockTemplate msg)
    {
        _templates.Remove(msg.TemplateId);
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeUpdateBlockInstance(UpdateBlockInstance msg)
    {
        var instance = _instances.FirstOrDefault(o => o.BlockId == msg.BlockId);
        instance.Position.X = msg.Position.X;
        instance.Position.Y = msg.Position.Y;
        instance.RotationZ = msg.RotationZ;
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRequestRaycast(RequestRaycast msg)
    {
        if (  msg.Ray.Origin.Z!=0)
        {
            throw new InvalidOperationException("Unsupported ray origin Z coordinate");
        }
        
        var pos = new Vector3(msg.Ray.Origin.X, msg.Ray.Origin.Y, msg.Ray.Origin.Z);
        var dir = new Vector3(msg.Ray.Direction.X, msg.Ray.Direction.Y, msg.Ray.Direction.Z);

        if ( Vector3.DistanceSquared(dir, new Vector3(0, 0, -1))>0.0001)
        {
            throw new InvalidOperationException("Unsupported ray direction");
        }

        var hit = _instances.FirstOrDefault(i =>
        {
            var template = _templates[i.TemplateId];

            var extents = new Vector2(template.Size.X, template.Size.Y)/2;
            var position = new Vector2(i.Position.X, i.Position.Y);
            var aabb = (min: position - extents, max: position + extents);

            return pos.X >= aabb.min.X
                   && pos.Y >= aabb.min.Y
                   && pos.X <= aabb.max.X
                   && pos.Y <= aabb.max.Y;
        });
        
        OnRaycastResponse?.Invoke(new RaycastResponse()
        {
            RequestId = msg.RequestId,
            HitBlockId = hit?.BlockId,
            HitWorld = new Vector3(pos.X,pos.Y, hit!=null?_templates[hit.TemplateId].Size.Z:pos.Z)
        });
        
        return ValueTask.CompletedTask;
    }


    public bool IsProcessingMessages { get; private set; }
    
    public void StartProcessingMessages()
    {
        //TODO 
    }

    public void StopProcessingMessages()
    {
        //TODO 
    }

    public event Action<ScreenToWorldRayResponse>? OnScreenToWorldRayResponse;
    public ValueTask InvokeRequestScreenToWorldRay(RequestScreenToWorldRay msg)
    {
        var worldToScreen = Matrix4x4.Multiply(Matrix4x4.CreateTranslation(new Vector3(offsetX, offsetY, 0)),Matrix4x4.CreateScale(new Vector3(scale, scale, 1)));
        
        var screenToWorld = Matrix4x4.Invert(worldToScreen, out var temp1) ? temp1 : throw new InvalidOperationException("Non invertable matrix");
        
        var rayOrigin = new Vector3(msg.Screen.X,msg.Screen.Y, 0);
        var rayDirection = new Vector3(0,0, -1);
        
        rayOrigin=Vector3.Transform(rayOrigin,screenToWorld);
        rayDirection=Vector3.TransformNormal(rayDirection,screenToWorld);

        OnScreenToWorldRayResponse?.Invoke(new ScreenToWorldRayResponse()
        {
            RequestId = msg.RequestId,
            Ray=new Ray(rayOrigin,rayDirection)
        });
        return ValueTask.CompletedTask;
    }
}
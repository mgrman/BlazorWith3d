@using System.Drawing
@using System.Globalization
@using System.Numerics
@using BlazorWith3d.ExampleApp.Client.Shared
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@implements IBlocksOnGrid3DRenderer
@implements IDisposable
@inject ILogger<BlocksOnGridHTMLComponent> Logger
@inject IJSRuntime JsRuntime

<div @ref=_rendererContainerReference class="my-component" style="width:100%; height: 100%; position: relative">

    @if (_instances.Count > 0)
    {
        var minHeight = _templates.Values.Select(o => o.Size.Z).Min();
        var maxHeight = _templates.Values.Select(o => o.Size.Z).Max();
        var heightRange = maxHeight - minHeight;

        foreach(var(instance, template) in _instances.Select(instance => (instance, template: _templates[instance.TemplateId])))
        {
            var brightness = (byte)(((template.Size.Z - minHeight) / heightRange) * 255);
            var color = ColorTranslator.ToHtml(Color.FromArgb(brightness, 0, 255-brightness));
            <div class="my-component" 
            style="user-select: none; position: absolute; width: @ToStringCSS((template.Size.X)*scale)px; height: @ToStringCSS((template.Size.Y)*scale)px; background-color: @color; left: @ToStringCSS((instance.Position.X-template.Size.X/2+offsetX)*scale)px; bottom: @ToStringCSS((instance.Position.Y-template.Size.Y/2+offsetY)*scale)px; rotate: @ToStringCSS(instance.RotationZ)deg;"
            >
                @instance.BlockId
            </div>
        }
    }

</div>

@code
{

    private  float canvasSizeX ;
    private  float canvasSizeY ;

    private string ToStringCSS(float val) => val.ToString(CultureInfo.InvariantCulture);
    private float scale;
    private  float offsetX ;
    private  float offsetY ;

    private readonly Dictionary<int,AddBlockTemplate> _templates = new ();
    private readonly List<AddBlockInstance> _instances = new();
    private ElementReference _rendererContainerReference;

    private IJSObjectReference jsInteropModule;
    private IBlocksOnGrid3DController? _eventHandler;
    private IDisposable? _rendererAssignment;

    [CascadingParameter] 
    public required I3DAppController ParentApp { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }

        jsInteropModule = await new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.ExampleApp.Client.HTML/jsInterop.js").AsTask()).Value;

        _rendererAssignment= await ParentApp.InitializeRenderer(this,null);

        var bounds = await GetBoundingClientRect(_rendererContainerReference);

        var desiredCanvasSize = 10f;

        scale = Math.Min(bounds.Width / desiredCanvasSize, bounds.Height / desiredCanvasSize);

        canvasSizeX = bounds.Width / scale;
        canvasSizeY = bounds.Height / scale;

        offsetX = canvasSizeX / 2;
        offsetY = canvasSizeY / 2;

        StateHasChanged();

        await base.OnAfterRenderAsync(firstRender);
    }

public void Dispose()
{
    _rendererAssignment?.Dispose();
}

    private async ValueTask<RectangleF> GetBoundingClientRect(ElementReference elementReference)
    {
        return await jsInteropModule.InvokeAsync<RectangleF>("getBoundingClientRect", elementReference);
    }


    public event Action<byte[], Exception>? OnMessageError;

    public ValueTask InvokeBlazorControllerInitialized(BlazorControllerInitialized msg)
    {
        Logger.LogInformation("BlazorControllerInitialized");
        return ValueTask.CompletedTask;
    }

    public async ValueTask<PerfCheck> InvokePerfCheck(PerfCheck msg)
    {
        return msg;
    }

    public ValueTask InvokeAddBlockTemplate(AddBlockTemplate msg)
    {
        _templates[msg.TemplateId] = msg;
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeAddBlockInstance(AddBlockInstance msg)
    {
        _instances.Add(msg);
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRemoveBlockInstance(RemoveBlockInstance msg)
    {
        _instances.RemoveAll(o=>o.BlockId== msg.BlockId);
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRemoveBlockTemplate(RemoveBlockTemplate msg)
    {
        _templates.Remove(msg.TemplateId);
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeUpdateBlockInstance(UpdateBlockInstance msg)
    {
        var instance = _instances.FirstOrDefault(o => o.BlockId == msg.BlockId);
        instance.Position = new PackableVector2(){X=msg.Position.X,Y= msg.Position.Y};
        instance.RotationZ = msg.RotationZ;
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public async ValueTask<RaycastResponse> InvokeRequestRaycast(RequestRaycast msg)
    {
        if (  msg.Ray.Origin.Z!=10)
        {
            throw new InvalidOperationException("Unsupported ray origin Z coordinate");
        }
        
        var pos = new Vector3(msg.Ray.Origin.X, msg.Ray.Origin.Y, msg.Ray.Origin.Z);
        var dir = new Vector3(msg.Ray.Direction.X, msg.Ray.Direction.Y, msg.Ray.Direction.Z);

        if ( Vector3.DistanceSquared(dir, new Vector3(0, 0, -1))>0.0001)
        {
            throw new InvalidOperationException("Unsupported ray direction");
        }

        var hit = _instances.FirstOrDefault(i =>
        {
            var template = _templates[i.TemplateId];

            var extents = new Vector2(template.Size.X, template.Size.Y)/2;
            var position = new Vector2(i.Position.X, i.Position.Y);
            var aabb = (min: position - extents, max: position + extents);

            return pos.X >= aabb.min.X
                   && pos.Y >= aabb.min.Y
                   && pos.X <= aabb.max.X
                   && pos.Y <= aabb.max.Y;
        });
        
        return new RaycastResponse()
        {
            HitBlockId = hit?.BlockId,
            HitWorld = new Vector3(pos.X,pos.Y, hit!=null?_templates[hit.TemplateId].Size.Z:pos.Z)
        };
    }


    public async ValueTask<ScreenToWorldRayResponse> InvokeRequestScreenToWorldRay(RequestScreenToWorldRay msg)
    {
        var worldToScreen = Matrix4x4.Multiply(Matrix4x4.Multiply(Matrix4x4.CreateScale(new Vector3(1, -1, 1)),Matrix4x4.CreateTranslation(new Vector3(offsetX, offsetY, 0))),Matrix4x4.CreateScale(new Vector3(scale, scale, 1)));
        
        var screenToWorld = Matrix4x4.Invert(worldToScreen, out var temp1) ? temp1 : throw new InvalidOperationException("Non invertable matrix");
        
        var rayOrigin = new Vector3(msg.Screen.X,msg.Screen.Y, 10);
        var rayDirection = new Vector3(0,0, -1);
        
        rayOrigin=Vector3.Transform(rayOrigin,screenToWorld);
        rayDirection=Vector3.TransformNormal(rayDirection,screenToWorld);

        return new ScreenToWorldRayResponse()
        {
            Ray = new Ray(rayOrigin, rayDirection)
        };
    }
    
    public async ValueTask InvokeTriggerTestToBlazor(TriggerTestToBlazor msg)
    {
        await Task.Delay(1000);

        var id = Random.Shared.Next();
        var response = await _eventHandler.OnTestToBlazor(new TestToBlazor(){Id = id});

        if (response.Id != id)
        {
            throw new InvalidOperationException();
        }
        Logger.LogCritical("TriggerTestToBlazor is done");
    }

    public void SetController(IBlocksOnGrid3DController? controller)
    {
        _eventHandler = controller;
        controller?.OnUnityAppInitialized(new UnityAppInitialized());
    }
}
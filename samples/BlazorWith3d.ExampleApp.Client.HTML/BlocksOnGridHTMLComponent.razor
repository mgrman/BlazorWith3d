@using System.Drawing
@using System.Globalization
@using System.Numerics
@using BlazorWith3d.ExampleApp.Client.Shared
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@implements IBlocksOnGrid3DRenderer
@implements IBlocksOnGrid3DBlazorRenderer
@implements IAsyncDisposable
@inject ILogger<BlocksOnGridHTMLComponent> Logger
@inject IJSRuntime JsRuntime

<div @ref=_rendererContainerReference class="my-component" style="width: 500px; height: 500px; position: relative; border: red 1px solid; user-select: none; background-color: @(_backgroundColor.ToCss())">

    @if (_instances.Count > 0)
    {
        var minHeight = _templates.Values.Select(o => o.Size.Z).Min();
        var maxHeight = _templates.Values.Select(o => o.Size.Z).Max();
        var heightRange = maxHeight - minHeight;

        var minColor = Color.FromArgb(60,60,60);
        var maxColor = Color.FromArgb(180,180,180);

        foreach(var(instance, template) in _instances.Select(instance => (instance, template: _templates[instance.TemplateId])))
        {
            var brightness = heightRange==0?1f: (template.Size.Z - minHeight) / heightRange ;
            var color = ColorUtils.Lerp(minColor, maxColor, brightness);
            <div class="my-component" 
            style="user-select: none; 
                position: absolute; 
                width: @ToStringCSS((template.Size.X)*scale)px; 
                height: @ToStringCSS((template.Size.Y)*scale)px; 
                background-color: @(string.IsNullOrEmpty(template.Visuals2dUri)?color.ToCss():""); 
                left: @ToStringCSS((instance.Position.X-template.Size.X/2+offsetX)*scale)px;
                bottom: @ToStringCSS((instance.Position.Y-template.Size.Y/2+offsetY)*scale)px;
                background-image: @(string.IsNullOrEmpty(template.Visuals2dUri)?"":$"url({template.Visuals2dUri})");
                background-size: contain;
                rotate: @ToStringCSS(instance.RotationZ)deg;"
            >
                
            </div>
        }
    }

</div>

@code
{

    private  float canvasSizeX ;
    private  float canvasSizeY ;

    private string ToStringCSS(float val) => val.ToString(CultureInfo.InvariantCulture);
    private float scale;
    private  float offsetX ;
    private  float offsetY ;

    private readonly Dictionary<int,AddBlockTemplate> _templates = new ();
    private readonly List<AddBlockInstance> _instances = new();
    private ElementReference _rendererContainerReference;

    private IJSObjectReference jsInteropModule;
    private IBlocksOnGrid3DController? _eventHandler;
    private Color _backgroundColor = Color.Azure;

    [CascadingParameter] 
    public required IBlocksOnGrid3DBlazorController ParentApp { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }

        jsInteropModule = await new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.ExampleApp.Client.HTML/jsInterop.js").AsTask()).Value;

        _eventHandler = ParentApp;
        
        await ParentApp.AddRenderer(this);

        var bounds = await GetBoundingClientRect(_rendererContainerReference);

        var desiredCanvasSize = 10f;

        scale = Math.Min(bounds.Width / desiredCanvasSize, bounds.Height / desiredCanvasSize);

        canvasSizeX = bounds.Width / scale;
        canvasSizeY = bounds.Height / scale;

        offsetX = canvasSizeX / 2;
        offsetY = canvasSizeY / 2;

        StateHasChanged();

        await base.OnAfterRenderAsync(firstRender);
    }
    
    IBlocksOnGrid3DRenderer IBlocksOnGrid3DBlazorRenderer.RendererApi => this;
    ElementReference IBlocksOnGrid3DBlazorRenderer.RendererContainer => _rendererContainerReference;

    public async ValueTask DisposeAsync()
    {
        await ParentApp.RemoveRenderer(this);
    }

    private async ValueTask<RectangleF> GetBoundingClientRect(ElementReference elementReference)
    {
        return await jsInteropModule.InvokeAsync<RectangleF>("getBoundingClientRect", elementReference);
    }
    public async ValueTask InitializeRenderer(RendererInitializationInfo msg)
    {
        Logger.LogInformation("InitializeRenderer");

        _backgroundColor = msg.BackgroundColor.ToColor();
        StateHasChanged();
        _eventHandler?.OnRendererInitialized(new RendererInitialized(), this);

    }

    public async ValueTask<PerfCheck> InvokePerfCheck(PerfCheck msg)
    {
        return msg;
    }

    public ValueTask InvokeAddBlockTemplate(AddBlockTemplate msg)
    {
        _templates[msg.TemplateId] = msg;
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeAddBlockInstance(AddBlockInstance msg)
    {
        _instances.Add(msg);
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRemoveBlockInstance(RemoveBlockInstance msg)
    {
        _instances.RemoveAll(o=>o.BlockId== msg.BlockId);
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeRemoveBlockTemplate(RemoveBlockTemplate msg)
    {
        _templates.Remove(msg.TemplateId);
        return ValueTask.CompletedTask;
    }

    public ValueTask InvokeUpdateBlockInstance(int blockId, PackableVector2 position,float rotationZ)
    {
        var instance = _instances.FirstOrDefault(o => o.BlockId == blockId);
        instance.Position = position;
        instance.RotationZ = rotationZ;
        StateHasChanged();
        return ValueTask.CompletedTask;
    }

    public async ValueTask<RaycastResponse> InvokeRequestRaycast(RequestRaycast msg)
    {
        if (  msg.Ray.Origin.Z!=10)
        {
            throw new InvalidOperationException("Unsupported ray origin Z coordinate");
        }
        
        var pos = new Vector3(msg.Ray.Origin.X, msg.Ray.Origin.Y, msg.Ray.Origin.Z);
        var dir = new Vector3(msg.Ray.Direction.X, msg.Ray.Direction.Y, msg.Ray.Direction.Z);

        if ( Vector3.DistanceSquared(dir, new Vector3(0, 0, -1))>0.0001)
        {
            throw new InvalidOperationException("Unsupported ray direction");
        }

        var hit = _instances.FirstOrDefault(i =>
        {
            var template = _templates[i.TemplateId];

            var extents = new Vector2(template.Size.X, template.Size.Y)/2;
            var position = new Vector2(i.Position.X, i.Position.Y);
            var aabb = (min: position - extents, max: position + extents);

            return pos.X >= aabb.min.X
                   && pos.Y >= aabb.min.Y
                   && pos.X <= aabb.max.X
                   && pos.Y <= aabb.max.Y;
        });
        
        return new RaycastResponse()
        {
            IsBlockHit= hit !=null,
            HitBlockId = hit?.BlockId??0,
            HitWorld = new Vector3(pos.X,pos.Y, hit!=null?_templates[hit.TemplateId].Size.Z:pos.Z)
        };
    }


    public async ValueTask<ScreenToWorldRayResponse> InvokeRequestScreenToWorldRay(RequestScreenToWorldRay msg)
    {
        var worldToScreen = Matrix4x4.Multiply(Matrix4x4.Multiply(Matrix4x4.CreateScale(new Vector3(1, -1, 1)),Matrix4x4.CreateTranslation(new Vector3(offsetX, offsetY, 0))),Matrix4x4.CreateScale(new Vector3(scale, scale, 1)));
        
        var screenToWorld = Matrix4x4.Invert(worldToScreen, out var temp1) ? temp1 : throw new InvalidOperationException("Non invertable matrix");
        
        var rayOrigin = new Vector3(msg.Screen.X,msg.Screen.Y, 10);
        var rayDirection = new Vector3(0,0, -1);
        
        rayOrigin=Vector3.Transform(rayOrigin,screenToWorld);
        rayDirection=Vector3.TransformNormal(rayDirection,screenToWorld);

        return new ScreenToWorldRayResponse()
        {
            Ray = new Ray(rayOrigin, rayDirection)
        };
    }
    
    public async ValueTask InvokeTriggerTestToBlazor(TriggerTestToBlazor msg)
    {
        await Task.Delay(1000);

        var id = Random.Shared.Next();
        var response = await _eventHandler.OnTestToBlazor(new TestToBlazor(){Id = id});

        if (response.Id != id)
        {
            throw new InvalidOperationException();
        }
        Logger.LogCritical("TriggerTestToBlazor is done");
    }

}
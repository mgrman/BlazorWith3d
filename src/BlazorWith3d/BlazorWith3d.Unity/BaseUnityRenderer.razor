@inject IJSRuntime JsRuntime
@inject ILogger<BaseUnityRenderer> Logger
@implements BlazorWith3d.Shared.IBinaryApiWithResponse
@using BlazorWith3d.Shared
@using Microsoft.Extensions.Logging
@implements IAsyncDisposable

<div @ref="_containerElementReference" class="unity-container" style="width: 100%; height: 100%; position: relative;"  >

    <canvas id="unity-canvas" width="100" height="100" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
            <div id="unity-progress-bar-full"></div>
        </div>
    </div>
    <div id="unity-warning"> </div>
</div>


@code
{
    private IJSObjectReference? _unityApi;

    private ElementReference _containerElementReference;
    private DotNetObjectReference<JsMessageReceiverProxy>? _messageReceiverProxyReference;

    public virtual string UnityBuildFilesRootPath => Assets[""];

    [Parameter] public bool IsWithResponse { get; set; }

    private SemaphoreSlim acesssSemaphore = new SemaphoreSlim(1, 1);


    public async ValueTask DisposeAsync()
    {

        if (_unityApi != null)
        {
            await _unityApi.InvokeVoidAsync("Quit");
            await _unityApi.DisposeAsync();
            _unityApi = null;
        }


        _messageReceiverProxyReference?.Dispose();
    }

    protected override void OnInitialized()
    {
        _messageReceiverProxyReference = DotNetObjectReference.Create(new JsMessageReceiverProxy(OnMessageBytesReceived, OnMessageWithResponseBytesReceived));
        base.OnInitialized();
    }



    protected async Task InitializeUnityApp()
    {
        var moduleTask = new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.Unity/unityInitialization.js").AsTask());
        var module = await moduleTask.Value;

        _unityApi = await module.InvokeAsync<IJSObjectReference>("showUnity", UnityBuildFilesRootPath, _containerElementReference, _messageReceiverProxyReference, nameof(JsMessageReceiverProxy.OnMessageBytesReceived), nameof(JsMessageReceiverProxy.OnMessageBytesReceivedWithResponse), IsWithResponse);

    }

    public Func<ArraySegment<byte>, ValueTask>? MainMessageHandler { get; set; }

    private ValueTask OnMessageBytesReceived(byte[] messageBytes)
    {
        return MainMessageHandler.Invoke(messageBytes);
    }

    private async ValueTask<byte[]> OnMessageWithResponseBytesReceived(byte[] messageBytes)
    {
        var response= await MainMessageWithResponseHandler.Invoke(messageBytes);
        var responseByteArray= response.WrittenArray.ToArray();// ToArray() as JS interop only has fast path for byte[] type
        response.Dispose();
        return responseByteArray;
    }

    public async ValueTask SendMessage(IBufferWriterWithArraySegment<byte> messageBytes)
    {
        if (_unityApi == null)
        {
            throw new InvalidOperationException();
        }

        try
        {
            await acesssSemaphore.WaitAsync();
            await _unityApi.InvokeVoidAsync("SendMessage", messageBytes.WrittenArray.ToArray());
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error sending message");
            throw;
        }
        finally
        {
            messageBytes.Dispose();
            acesssSemaphore.Release();
        }
    }

    private class JsMessageReceiverProxy(Func<byte[], ValueTask> onMessageBytesReceived, Func<byte[], ValueTask<byte[]>> onMessageWithResponseBytesReceived)
    {
        [JSInvokable]
        public ValueTask OnMessageBytesReceived(byte[] msg)
        {
            return onMessageBytesReceived(msg);
        }

        [JSInvokable]
        public ValueTask<byte[]> OnMessageBytesReceivedWithResponse(byte[] msg)
        {
            return onMessageWithResponseBytesReceived(msg);
        }
    }

    public Func<ArraySegment<byte>, ValueTask<IBufferWriterWithArraySegment<byte>>>? MainMessageWithResponseHandler { get; set; }

    public async ValueTask<ArraySegment<byte>> SendMessageWithResponse(IBufferWriterWithArraySegment<byte> bytes)
    {
        if (_unityApi == null)
        {
            throw new InvalidOperationException();
        }

        try
        {
            await acesssSemaphore.WaitAsync();
            return await _unityApi.InvokeAsync<byte[]>("SendMessageWithResponse", bytes.WrittenArray.ToArray());
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error sending message");
            throw;
        }
        finally
        {
            bytes.Dispose();
            acesssSemaphore.Release();
        }
    }
}
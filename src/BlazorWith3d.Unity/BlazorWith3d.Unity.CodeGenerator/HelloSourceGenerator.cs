using System.Collections.Generic;
using System.Linq;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BlazorWith3d.Unity.CodeGenerator;

[Generator]
public class HelloSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context) // Implement Execute method
    {
        // retrieve the populated receiver 
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (!receiver.ShouldGenerate)
        {
            return;
        }
        
    
        var methodInfo = GetMethodsInfo(receiver);
        
        foreach (var typeDeclaration in receiver.Blazor3DAppTypes)
        {
            var (typeName,namespaceName) = GetTypeAndNamespace(typeDeclaration);

            var appInfo= new AppInfo(typeName, namespaceName, "TypedUnityApi","ValueTask", methodInfo.messagesToUnity, methodInfo.messagesToBlazor, methodInfo);
            
            var text = GenerateClass(appInfo);
            context.AddSource($"{typeName}.g.cs", text);
        }

        foreach (var typeDeclaration in receiver.Unity3DAppTypes)
        {
            var (typeName,namespaceName) = GetTypeAndNamespace(typeDeclaration);

            var appInfo= new AppInfo(typeName, namespaceName, "TypedBlazorApi","void", methodInfo.messagesToBlazor, methodInfo.messagesToUnity, methodInfo);

            var text = GenerateClass(appInfo);

            context.AddSource($"{typeName}.g.cs", text);
        }
    }

    private static (string type, string @namespace) GetTypeAndNamespace(TypeDeclarationSyntax typeDeclaration)
    {
        var typeName = typeDeclaration.Identifier.ToString();
        var namespaceName = (typeDeclaration.Parent as NamespaceDeclarationSyntax).Name.ToString();
        return (typeName,namespaceName);
    }

    private record AppInfo(
        string typeName,
        string @namespace,
        string typedApiName,
        string sendMessageReturnType,
        IReadOnlyList<(string typeName, string @namespace)> methods,
        IReadOnlyList<(string typeName, string @namespace)> events,
        MessageInfo allMessages)
    {
    }
    private record MessageInfo(
        IReadOnlyList<(string typeName, string @namespace)> messagesToUnity,
        IReadOnlyList<(string typeName, string @namespace)> messagesToBlazor)
    {
    }

    private static string GenerateClass( AppInfo info)
    {
        var sb = new IndentedStringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLines(info.allMessages.messagesToUnity.Concat(info.allMessages.messagesToBlazor).Select(o=>o.@namespace).Distinct().Select(o => $"using {o};"));
        sb.AppendLine("using BlazorWith3d.Unity.Shared;");
        sb.AppendLine("using MemoryPack;");
        sb.AppendLine("using MemoryPack.Formatters;");
        sb.AppendLine($"namespace {info.@namespace}");
        using (sb.IndentWithCurlyBrackets())
        {
            sb.AppendLine($"public partial interface I{info.typeName}");
            using (sb.IndentWithCurlyBrackets())
            {

                foreach (var e in info.events)
                {
                    sb.AppendLine($"event Action<{e.typeName}> On{e.typeName};");
                }

                sb.AppendLine();
                foreach (var m in info.methods)
                {
                    sb.AppendLine($"{info.sendMessageReturnType} Invoke{m.typeName}({m.typeName} msg);");

                }

            }
            
            sb.AppendLine($"public partial class {info.typeName}: I{info.typeName}");
            using (sb.IndentWithCurlyBrackets())
            {
                    
                sb.AppendLine($"private static bool _memoryPackInitialized;");
                sb.AppendLine($"public static void InitializeMemoryPack()");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine($"if(_memoryPackInitialized){{return;}}");
                    sb.AppendLine($"_memoryPackInitialized = true;");
                        
                    sb.AppendLine("var messageMethodFormatter = new DynamicUnionFormatter<IMessageToBlazor>(");
                    using (sb.Indent())
                    {
                        for (var i = 0; i < info.allMessages.messagesToBlazor.Count; i++)
                        {
                            var m = info.allMessages.messagesToBlazor[i].typeName;
                            sb.AppendLine($"({i},typeof({m})){(i != info.allMessages.messagesToBlazor.Count - 1 ? "," : "")}");
                        }
                    }
                        
                    sb.AppendLine(");");
                        
                    sb.AppendLine("var messageToUnityFormatter = new DynamicUnionFormatter<IMessageToUnity>(");
                    using (sb.Indent())
                    {
                        for (var i = 0; i < info.allMessages.messagesToUnity.Count; i++)
                        {
                            var m = info.allMessages.messagesToUnity[i].typeName;
                            sb.AppendLine($"({i},typeof({m})){(i != info.allMessages.messagesToUnity.Count - 1 ? "," : "")}");
                        }
                    }
                        
                    sb.AppendLine(");");
                        
                    sb.AppendLine("MemoryPackFormatterProvider.Register(messageMethodFormatter);");
                    sb.AppendLine("MemoryPackFormatterProvider.Register(messageToUnityFormatter);");
                        
                }
                
                

                sb.AppendLine($"private readonly {info.typedApiName} _typedApi;");
                sb.AppendLine();
                sb.AppendLine($"public {info.typeName}({info.typedApiName} typedApi)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("_typedApi = typedApi;");

                    foreach (var e in info.events)
                    {
                        sb.AppendLine(
                            $"_typedApi.AddMessageProcessCallback<{e.typeName}>(this.On{e.typeName}Internal);");
                    }
                }

                sb.AppendLine();

                foreach (var e in info.events)
                {
                    sb.AppendLine($"public event Action<{e.typeName}> On{e.typeName};");
                }

                sb.AppendLine();
                foreach (var m in info.methods)
                {
                    sb.AppendLine($"public {info.sendMessageReturnType} Invoke{m.typeName}({m.typeName} msg)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine($"{(info.sendMessageReturnType=="void"?"":"return ")}_typedApi.SendMessage(msg);");
                    }
                }
                sb.AppendLine();

                foreach (var e in info.events)
                {
                    sb.AppendLine(
                        $"private void On{e.typeName}Internal({e.typeName} msg)=> On{e.typeName}?.Invoke(msg);");
                }
            }
        }
        
        return sb.ToString();
    }

    private static MessageInfo GetMethodsInfo(SyntaxReceiver receiver)
    {
            
        var messagesToUnity = receiver.MessagesToUnity
            .Select(typeDeclaration =>
            {
                return GetTypeAndNamespace(typeDeclaration);
            }).ToList();
        var messagesToBlazor = receiver.MessagesToBlazor
            .Select(typeDeclaration =>
            {
                return GetTypeAndNamespace(typeDeclaration);
            }).ToList();
        
        return new MessageInfo(messagesToUnity, messagesToBlazor);
    }


    /// <summary>
    ///     Created on demand before each generation pass
    /// </summary>
    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public bool ShouldGenerate => Blazor3DAppTypes.Count > 0 || Unity3DAppTypes.Count>0;

        public List<TypeDeclarationSyntax > Blazor3DAppTypes { get; } = new();

        public List<TypeDeclarationSyntax > Unity3DAppTypes { get; } = new();

        public List<TypeDeclarationSyntax > MessagesToUnity { get; } = new();

        public List<TypeDeclarationSyntax > MessagesToBlazor { get; } = new();

        /// <summary>
        ///     Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for
        ///     generation
        /// </summary>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is TypeDeclarationSyntax typeDeclarationSyntax)
            {
                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes)
                    .Any(e => e.Name.NormalizeWhitespace().ToFullString() == "Blazor3DApp"))
                {
                    Blazor3DAppTypes.Add(typeDeclarationSyntax);
                }

                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes)
                    .Any(e => e.Name.NormalizeWhitespace().ToFullString() == "Unity3DApp"))
                {
                    Unity3DAppTypes.Add(typeDeclarationSyntax);
                }
           
                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes).Any(e =>
                        e.Name.NormalizeWhitespace().ToFullString() == "MemoryPackable") && (typeDeclarationSyntax.BaseList?.Types.Any(o=>o.Type.ToString() == "IMessageToUnity") ?? false))
                {
                    MessagesToUnity.Add(typeDeclarationSyntax);
                }

                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes).Any(e =>
                        e.Name.NormalizeWhitespace().ToFullString() == "MemoryPackable") && (typeDeclarationSyntax.BaseList?.Types.Any(o=>o.Type.ToString() == "IMessageToBlazor") ?? false))
                {
                    MessagesToBlazor.Add(typeDeclarationSyntax);
                }
            }
        }
    }
}

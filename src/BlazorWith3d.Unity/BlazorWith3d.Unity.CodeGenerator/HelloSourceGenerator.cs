using System.Collections.Generic;
using System.Linq;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BlazorWith3d.Unity.CodeGenerator;

[Generator]
public class HelloSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context) // Implement Execute method
    {
        // retrieve the populated receiver 
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (!receiver.ShouldGenerate)
        {
            return;
        }
        
    
        var messagesToUnity = receiver.MessagesToUnity
            .Select(typeDeclaration =>
            {
                return GetTypeAndNamespace(typeDeclaration);
            }).ToList();
        
        var messagesToBlazor = receiver.MessagesToBlazor
            .Select(typeDeclaration =>
            {
                return GetTypeAndNamespace(typeDeclaration);
            }).ToList();

        var namespacesToInclude = messagesToUnity.Concat(messagesToBlazor).Select(o => o.@namespace).ToList();
        
        foreach (var typeDeclaration in receiver.Blazor3DAppTypes)
        {
            var (typeName,namespaceName,_) = GetTypeAndNamespace(typeDeclaration.type);

            var appInfo= new AppInfo(typeName, namespaceName, typeDeclaration.generateObjectApi,  messagesToUnity, messagesToBlazor, namespacesToInclude);
            
            var text = GenerateClass(appInfo);
            context.AddSource($"{typeName}.g.cs", text);
        }

        foreach (var typeDeclaration in receiver.Unity3DAppTypes)
        {
            var (typeName,namespaceName,_) = GetTypeAndNamespace(typeDeclaration.type);

            var appInfo= new AppInfo(typeName, namespaceName,typeDeclaration.generateObjectApi,  messagesToBlazor, messagesToUnity, namespacesToInclude);

            var text = GenerateClass(appInfo);

            context.AddSource($"{typeName}.g.cs", text);
        }
    }

    private static (string type, string @namespace, bool isPublic) GetTypeAndNamespace(TypeDeclarationSyntax typeDeclaration)
    {
        var typeName = typeDeclaration.Identifier.ToString();
        var namespaceName = (typeDeclaration.Parent as NamespaceDeclarationSyntax).Name.ToString();
        var isPublic = typeDeclaration.Modifiers.Any(o=>o.ToString()== "public");
        return (typeName,namespaceName,isPublic);
    }

    private record AppInfo(
        string typeName,
        string @namespace,
        bool generateObjectApi,
        IReadOnlyList<(string typeName, string @namespace, bool isPublic)> methods,
        IReadOnlyList<(string typeName, string @namespace, bool isPublic)> events,
        IReadOnlyList<string> namespacesToInclude)
    {
    }

    private static string GenerateClass( AppInfo info)
    {
        var sb = new IndentedStringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLines(info.namespacesToInclude.Distinct().Select(o => $"using {o};"));
        sb.AppendLine("using BlazorWith3d.Unity.Shared;");
        sb.AppendLine("using MemoryPack;");
        sb.AppendLine("using MemoryPack.Formatters;");
        sb.AppendLine($"namespace {info.@namespace}");
        using (sb.IndentWithCurlyBrackets())
        {
            sb.AppendLine($"public partial interface I{info.typeName}");
            using (sb.IndentWithCurlyBrackets())
            {
                sb.AppendLine($"event Action<byte[], Exception> OnMessageError;");

                foreach (var e in info.events)
                {
                    sb.AppendLine($"event Action<{e.typeName}> On{e.typeName};");
                }

                sb.AppendLine();
                foreach (var m in info.methods)
                {
                    sb.AppendLine($"ValueTask Invoke{m.typeName}({m.typeName} msg);");
                }
            }
            
            sb.AppendLine();
            sb.AppendLine($"public partial  class {info.typeName}: I{info.typeName}{(info.generateObjectApi?", I3DAppObjectApi":"")}, IDisposable");
            using (sb.IndentWithCurlyBrackets())
            {
                sb.AppendLine($"protected partial void SerializeObject<T>(T obj, IBufferWriter<byte> writer);");
                sb.AppendLine($"protected partial T? DeserializeObject<T>(ReadOnlySpan<byte> bytes);");

                sb.AppendLine();
                sb.AppendLine($"private readonly IBinaryApi _binaryApi;");
                sb.AppendLine($"private readonly ArrayBufferWriter<byte> _writer = new ArrayBufferWriter<byte>(100);");
                sb.AppendLine();
                sb.AppendLine($"public {info.typeName}(IBinaryApi binaryApi)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("_binaryApi = binaryApi;");
                    sb.AppendLine("_binaryApi.OnMessage+=ProcessMessages;");
                }

                sb.AppendLine();

                sb.AppendLine($"public event Action<byte[], Exception> OnMessageError;");
                if (info.generateObjectApi)
                {
                    sb.AppendLine($"public event Action<(object msg, Type msgType)>? OnMessageObject;");
                }

                sb.AppendLine();
                foreach (var e in info.events)
                {
                    sb.AppendLine($"public event Action<{e.typeName}> On{e.typeName};");
                }

                sb.AppendLine();
                foreach(var (m,i)in info.methods.EnumerateWithIndex())
                {
                    sb.AppendLine($"public ValueTask Invoke{m.typeName}({m.typeName} msg)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine($"return SendMessage({i}, msg);");
                    }
                }
                sb.AppendLine();

                if (info.generateObjectApi)
                {
                    sb.AppendLine($"public ValueTask InvokeMessageObject(object msg, Type messageTypeOverride = null)");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine($"if(msg==null) throw new ArgumentNullException(nameof(msg));");
                        sb.AppendLine($"var msgType=messageTypeOverride ?? msg.GetType();");
                        foreach(var (m,i)in info.methods.EnumerateWithIndex())
                        {
                            sb.AppendLine($"if (msgType == typeof({m.typeName}))");
                            using (sb.IndentWithCurlyBrackets())
                            {
                                sb.AppendLine($"return SendMessage<{m.typeName}>({i}, ({m.typeName})msg);");
                            }
                        }

                        sb.AppendLine($"throw new InvalidOperationException($\"Unknown message type {{msgType.Name}}\");");
                    }

                    sb.AppendLine();
                    sb.AppendLine($"public IEnumerable<Type> SupportedOnMessageTypes ");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine($"get");
                        using (sb.IndentWithCurlyBrackets())
                        {
                            foreach(var (m,i)in info.events.EnumerateWithIndex())
                            {
                                sb.AppendLine($"yield return typeof({m.typeName});");
                            }
                        }
                    }

                    sb.AppendLine();
                    sb.AppendLine($"public IEnumerable<Type> SupportedInvokeMessageTypes ");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine($"get");
                        using (sb.IndentWithCurlyBrackets())
                        {
                            foreach(var (m,i)in info.methods.EnumerateWithIndex())
                            {
                                sb.AppendLine($"yield return typeof({m.typeName});");
                            }
                        }
                    }

                    sb.AppendLine();
                }
                
                sb.AppendLine();
                sb.AppendLine($"public void Dispose()");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("_binaryApi.OnMessage-=ProcessMessages;");
                }
                
                sb.AppendLine($"protected ValueTask SendMessage<TMessage>(byte messageId, TMessage message)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("try");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("_writer.Clear();");
                        sb.AppendLine("Span<byte> messageIdSpan = stackalloc byte[1];");
                        sb.AppendLine("messageIdSpan[0] = messageId;");
                        sb.AppendLine("_writer.Write(messageIdSpan);");
                        sb.AppendLine("SerializeObject(message, _writer);");
                        sb.AppendLine("var encodedMessage = _writer.WrittenSpan.ToArray();");
                        sb.AppendLine($"return _binaryApi.SendMessage(encodedMessage);");
                    }
                    sb.AppendLine("catch (Exception ex)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("throw;");
                    }
                }
                
                sb.AppendLine();

                
                sb.AppendLine($"protected void ProcessMessages(byte[] message)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("try");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("var span = new ReadOnlySpan<byte>(message, 1, message.Length - 1);");
                        
                        sb.AppendLine("switch(message[0])");
                        using (sb.IndentWithCurlyBrackets())
                        {
                            foreach(var (e,i)in info.events.EnumerateWithIndex())
                            {
                                sb.AppendLine($"case {i}:");
                                using (sb.IndentWithCurlyBrackets())
                                {
                                    sb.AppendLine($"var obj = DeserializeObject<{e.typeName}>(span);");
                                    sb.AppendLine($"On{e.typeName}?.Invoke(obj);");

                                    if (info.generateObjectApi)
                                    {
                                        sb.AppendLine($"OnMessageObject?.Invoke((obj, typeof({e.typeName})));");
                                    }

                                    sb.AppendLine($"break;");
                                }
                            }
                        }
                    }
                    sb.AppendLine("catch (Exception ex)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("OnMessageError?.Invoke(message, ex);");
                        sb.AppendLine("throw;");
                    }
                }
            }
        }
        
        return sb.ToString();
    }

    /// <summary>
    ///     Created on demand before each generation pass
    /// </summary>
    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public bool ShouldGenerate => Blazor3DAppTypes.Count > 0 || Unity3DAppTypes.Count>0;

        public List<(TypeDeclarationSyntax type, bool generateObjectApi) > Blazor3DAppTypes { get; } = new();

        public List<(TypeDeclarationSyntax type, bool generateObjectApi) > Unity3DAppTypes { get; } = new();

        public List<TypeDeclarationSyntax > MessagesToUnity { get; } = new();

        public List<TypeDeclarationSyntax > MessagesToBlazor { get; } = new();

        /// <summary>
        ///     Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for
        ///     generation
        /// </summary>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is TypeDeclarationSyntax typeDeclarationSyntax)
            {
                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes)
                    .TryGet(e => e.Name.NormalizeWhitespace().ToFullString() == "Blazor3DApp", out var blazor3DAppAttr))
                {
                    var aaa = bool.TryParse(blazor3DAppAttr.ArgumentList?.Arguments.Select(o => o.ToString()).FirstOrDefault(), out var value) ? value : false;
                    Blazor3DAppTypes.Add((typeDeclarationSyntax, aaa));
                }

                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes)
                    .TryGet(e => e.Name.NormalizeWhitespace().ToFullString() == "Unity3DApp", out var unity3DAppAttr))
                {
                    var aaa = bool.TryParse(unity3DAppAttr.ArgumentList?.Arguments.Select(o => o.ToString()).FirstOrDefault(), out var value) ? value : false;
                    Unity3DAppTypes.Add((typeDeclarationSyntax, aaa));
                }
           
                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes).Any(e =>
                        e.Name.NormalizeWhitespace().ToFullString() == "MemoryPackable") && (typeDeclarationSyntax.BaseList?.Types.Any(o=>o.Type.ToString() == "IMessageToUnity") ?? false))
                {
                    MessagesToUnity.Add(typeDeclarationSyntax);
                }

                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes).Any(e =>
                        e.Name.NormalizeWhitespace().ToFullString() == "MemoryPackable") && (typeDeclarationSyntax.BaseList?.Types.Any(o=>o.Type.ToString() == "IMessageToBlazor") ?? false))
                {
                    MessagesToBlazor.Add(typeDeclarationSyntax);
                }
            }
        }
    }
}

using System.Collections.Generic;
using System.Linq;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BlazorWith3d.Unity.CodeGenerator;

[Generator]
public class HelloSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context) // Implement Execute method
    {
        // retrieve the populated receiver 
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (!receiver.ShouldGenerate)
        {
            return;
        }
        
    
        var methodInfo = GetMethodsInfo(receiver);
        
        foreach (var typeDeclaration in receiver.Blazor3DAppTypes)
        {
            var (typeName,namespaceName) = GetTypeAndNamespace(typeDeclaration);

            var appInfo= new AppInfo(typeName, namespaceName,  methodInfo.messagesToUnity, methodInfo.messagesToBlazor, methodInfo);
            
            var text = GenerateClass(appInfo);
            context.AddSource($"{typeName}.g.cs", text);
        }

        foreach (var typeDeclaration in receiver.Unity3DAppTypes)
        {
            var (typeName,namespaceName) = GetTypeAndNamespace(typeDeclaration);

            var appInfo= new AppInfo(typeName, namespaceName,  methodInfo.messagesToBlazor, methodInfo.messagesToUnity, methodInfo);

            var text = GenerateClass(appInfo);

            context.AddSource($"{typeName}.g.cs", text);
        }
    }

    private static (string type, string @namespace) GetTypeAndNamespace(TypeDeclarationSyntax typeDeclaration)
    {
        var typeName = typeDeclaration.Identifier.ToString();
        var namespaceName = (typeDeclaration.Parent as NamespaceDeclarationSyntax).Name.ToString();
        return (typeName,namespaceName);
    }

    private record AppInfo(
        string typeName,
        string @namespace,
        IReadOnlyList<(string typeName, string @namespace)> methods,
        IReadOnlyList<(string typeName, string @namespace)> events,
        MessageInfo allMessages)
    {
    }
    private record MessageInfo(
        IReadOnlyList<(string typeName, string @namespace)> messagesToUnity,
        IReadOnlyList<(string typeName, string @namespace)> messagesToBlazor)
    {
    }

    private static string GenerateClass( AppInfo info)
    {
        var sb = new IndentedStringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLines(info.allMessages.messagesToUnity.Concat(info.allMessages.messagesToBlazor).Select(o=>o.@namespace).Distinct().Select(o => $"using {o};"));
        sb.AppendLine("using BlazorWith3d.Unity.Shared;");
        sb.AppendLine("using MemoryPack;");
        sb.AppendLine("using MemoryPack.Formatters;");
        sb.AppendLine($"namespace {info.@namespace}");
        using (sb.IndentWithCurlyBrackets())
        {
            sb.AppendLine($"public partial interface I{info.typeName}");
            using (sb.IndentWithCurlyBrackets())
            {
                    sb.AppendLine($"event Action<byte[], Exception> OnMessageError;");

                foreach (var e in info.events)
                {
                    sb.AppendLine($"event Action<{e.typeName}> On{e.typeName};");
                }

                sb.AppendLine();
                foreach (var m in info.methods)
                {
                    sb.AppendLine($"ValueTask Invoke{m.typeName}({m.typeName} msg);");

                }

            }
            
            sb.AppendLine($"public partial  class {info.typeName}: I{info.typeName}");
            using (sb.IndentWithCurlyBrackets())
            {
                    
              
                sb.AppendLine($"protected partial void SerializeObject<T>(T obj, IBufferWriter<byte> writer);");
                sb.AppendLine($"protected partial T? DeserializeObject<T>(ReadOnlySpan<byte> bytes);");

                sb.AppendLine($"private readonly IBinaryApi _binaryApi;");
                sb.AppendLine($"private readonly ArrayBufferWriter<byte> _writer = new ArrayBufferWriter<byte>(100);");
                sb.AppendLine();
                sb.AppendLine($"public {info.typeName}(IBinaryApi binaryApi)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("_binaryApi = binaryApi;");
                    sb.AppendLine("_binaryApi.OnMessage+=ProcessMessages;");
                }

                sb.AppendLine();

                sb.AppendLine($"public event Action<byte[], Exception> OnMessageError;");
                foreach (var e in info.events)
                {
                    sb.AppendLine($"public event Action<{e.typeName}> On{e.typeName};");
                }

                sb.AppendLine();
                for (var i = 0; i < info.methods.Count; i++)
                {
                    var m = info.methods[i];
                    sb.AppendLine($"public ValueTask Invoke{m.typeName}({m.typeName} msg)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine($"return SendMessage({i}, msg);");
                    }
                }

                sb.AppendLine();
                
                sb.AppendLine($"protected ValueTask SendMessage<TMessage>(byte messageId, TMessage message)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("try");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("_writer.Clear();");
                        sb.AppendLine("Span<byte> messageIdSpan = stackalloc byte[1];");
                        sb.AppendLine("messageIdSpan[0] = messageId;");
                        sb.AppendLine("_writer.Write(messageIdSpan);");
                        sb.AppendLine("SerializeObject(message, _writer);");
                        sb.AppendLine("var encodedMessage = _writer.WrittenSpan.ToArray();");
                        sb.AppendLine($"return _binaryApi.SendMessage(encodedMessage);");
                    }
                    sb.AppendLine("catch (Exception ex)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("throw;");
                    }
                }
                
                sb.AppendLine();

                
                sb.AppendLine($"protected void ProcessMessages(byte[] message)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("try");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("var span = new ReadOnlySpan<byte>(message, 1, message.Length - 1);");
                        
                        sb.AppendLine("switch(message[0])");
                        using (sb.IndentWithCurlyBrackets())
                        {
                            for (var i = 0; i < info.events.Count; i++)
                            {
                                var e = info.events[i];
                                sb.AppendLine($"case {i}:");
                                using (sb.IndentWithCurlyBrackets())
                                {
                                    sb.AppendLine($"var obj = DeserializeObject<{e.typeName}>(span);");
                                    sb.AppendLine($"On{e.typeName}?.Invoke(obj);");
                                    sb.AppendLine($"break;");
                                }
                            }
                        }
                    }
                    sb.AppendLine("catch (Exception ex)");

                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine("OnMessageError?.Invoke(message, ex);");
                        sb.AppendLine("throw;");
                    }
                }
            }
        }
        
        return sb.ToString();
    }

    private static MessageInfo GetMethodsInfo(SyntaxReceiver receiver)
    {
            
        var messagesToUnity = receiver.MessagesToUnity
            .Select(typeDeclaration =>
            {
                return GetTypeAndNamespace(typeDeclaration);
            }).ToList();
        var messagesToBlazor = receiver.MessagesToBlazor
            .Select(typeDeclaration =>
            {
                return GetTypeAndNamespace(typeDeclaration);
            }).ToList();
        
        return new MessageInfo(messagesToUnity, messagesToBlazor);
    }


    /// <summary>
    ///     Created on demand before each generation pass
    /// </summary>
    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public bool ShouldGenerate => Blazor3DAppTypes.Count > 0 || Unity3DAppTypes.Count>0;

        public List<TypeDeclarationSyntax > Blazor3DAppTypes { get; } = new();

        public List<TypeDeclarationSyntax > Unity3DAppTypes { get; } = new();

        public List<TypeDeclarationSyntax > MessagesToUnity { get; } = new();

        public List<TypeDeclarationSyntax > MessagesToBlazor { get; } = new();

        /// <summary>
        ///     Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for
        ///     generation
        /// </summary>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is TypeDeclarationSyntax typeDeclarationSyntax)
            {
                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes)
                    .Any(e => e.Name.NormalizeWhitespace().ToFullString() == "Blazor3DApp"))
                {
                    Blazor3DAppTypes.Add(typeDeclarationSyntax);
                }

                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes)
                    .Any(e => e.Name.NormalizeWhitespace().ToFullString() == "Unity3DApp"))
                {
                    Unity3DAppTypes.Add(typeDeclarationSyntax);
                }
           
                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes).Any(e =>
                        e.Name.NormalizeWhitespace().ToFullString() == "MemoryPackable") && (typeDeclarationSyntax.BaseList?.Types.Any(o=>o.Type.ToString() == "IMessageToUnity") ?? false))
                {
                    MessagesToUnity.Add(typeDeclarationSyntax);
                }

                if (typeDeclarationSyntax.AttributeLists.SelectMany(e => e.Attributes).Any(e =>
                        e.Name.NormalizeWhitespace().ToFullString() == "MemoryPackable") && (typeDeclarationSyntax.BaseList?.Types.Any(o=>o.Type.ToString() == "IMessageToBlazor") ?? false))
                {
                    MessagesToBlazor.Add(typeDeclarationSyntax);
                }
            }
        }
    }
}

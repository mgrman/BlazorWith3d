using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BlazorWith3d.Unity.CodeGenerator;

[Generator]
public class HelloSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context) // Implement Execute method
    {
        // retrieve the populated receiver 
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver)) return;

        if (!receiver.ShouldGenerate) return;

        var sb = new IndentedStringBuilder();


        sb.AppendLine("var messageMethodFormatter = new DynamicUnionFormatter<IMessageToBlazor>(");
        using (sb.Indent())
        {
            for (var i = 0; i < receiver.MessageToBlazorTypes.Count; i++)
            {
                var (type, _) = receiver.MessageToBlazorTypes[i];
                sb.AppendLine($"({i},typeof({type})){(i != receiver.MessageToBlazorTypes.Count - 1 ? "," : "")}");
            }
        }

        sb.AppendLine(");");

        sb.AppendLine("var messageToUnityFormatter = new DynamicUnionFormatter<IMessageToUnity>(");
        using (sb.Indent())
        {
            for (var i = 0; i < receiver.MessageToUnityTypes.Count; i++)
            {
                var (type, _) = receiver.MessageToUnityTypes[i];
                sb.AppendLine($"({i},typeof({type})){(i != receiver.MessageToUnityTypes.Count - 1 ? "," : "")}");
            }
        }

        sb.AppendLine(");");

        sb.AppendLine("MemoryPackFormatterProvider.Register(messageMethodFormatter);");
        sb.AppendLine("MemoryPackFormatterProvider.Register(messageToUnityFormatter);");

        var memPack = sb.ToString();

        foreach (var (unityApiType, unityApiTypeNamespace) in receiver.UnityApiTypes)
        {
            var text = CreateApiForSendingMessages(receiver.MessageToUnityTypes, receiver.MessageToBlazorTypes, memPack,
                unityApiType, unityApiTypeNamespace, "TypedUnityApi", "Task");
            context.AddSource($"{unityApiType}.g.cs", text);
        }

        foreach (var (blazorApiType, blazorApiTypeNamespace) in receiver.BlazorApiTypes)
        {
            var text = CreateApiForSendingMessages(receiver.MessageToBlazorTypes, receiver.MessageToUnityTypes, memPack,
                blazorApiType, blazorApiTypeNamespace, "TypedBlazorApi", "void");
            context.AddSource($"{blazorApiType}.g.cs", text);
        }
    }

    private static string CreateApiForSendingMessages(List<(string messageType, string namespac)> methodTypes,
        List<(string messageType, string namespac)> eventTypes, string memoryPackInitialization, string apiType,
        string apiTypeNamespace, string typedApiName, string sendMessageReturnType)
    {
        var sb = new IndentedStringBuilder();
        var namespaces = methodTypes.Concat(eventTypes).Select(o => o.namespac)
            .Distinct()
            .ToList();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLines(namespaces.Select(o => $"using {o};"));
        sb.AppendLine("using MemoryPack;");
        sb.AppendLine("using MemoryPack.Formatters;");
        sb.AppendLine("using BlazorWith3d.Unity;");
        sb.AppendLine("using BlazorWith3d.Unity.Shared;");
        sb.AppendLine($"namespace {apiTypeNamespace}");
        using (sb.IndentWithCurlyBrackets())
        {
            sb.AppendLine($"public partial class {apiType}");
            using (sb.IndentWithCurlyBrackets())
            {
                sb.AppendLine($"static {apiType}()");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine(memoryPackInitialization);
                }

                sb.AppendLine($"private readonly {typedApiName} _typedApi;");
                sb.AppendLine();
                sb.AppendLine($"public {apiType}({typedApiName} typedApi)");
                using (sb.IndentWithCurlyBrackets())
                {
                    sb.AppendLine("_typedApi = typedApi;");


                    foreach (var (messageType, _) in eventTypes)
                    {
                        var eventInvokeMethodName = $"Invoke{messageType}Event";
                        var callbackMethodName = "AddMessageProcessCallback";
                        var callbackMethodGenericArguments = messageType;
                        sb.AppendLine(
                            $"_typedApi.{callbackMethodName}<{callbackMethodGenericArguments}>(this.{eventInvokeMethodName});");
                    }
                }

                sb.AppendLine();

                foreach (var (messageType, _) in eventTypes)
                {
                    var eventType = $"Action<{messageType}>";

                    var eventName = $"On{messageType}";

                    sb.AppendLine($"public event {eventType} {eventName};");
                }

                sb.AppendLine();
                foreach (var (messageType, _) in methodTypes)
                {
                    var arguments = new[] { $"{messageType} msg" };
                    var methodName = $"Invoke{messageType}";
                    var sendMethodName = "SendMessage";

                    sb.AppendLine($"public {sendMessageReturnType} {methodName}({string.Join(", ", arguments)})");
                    using (sb.IndentWithCurlyBrackets())
                    {
                        sb.AppendLine(
                            $"{(sendMessageReturnType == "void" ? "" : "return ")}_typedApi.{sendMethodName}(msg);");
                    }
                }

                sb.AppendLine();


                foreach (var (messageType, _) in eventTypes)
                {
                    var methodReturnType = "void";

                    var arguments = new[] { $"{messageType} msg" };
                    var eventInvokeMethodName = $"Invoke{messageType}Event";
                    var eventName = $"On{messageType}";

                    sb.AppendLine(
                        $"private {methodReturnType} {eventInvokeMethodName}({string.Join(", ", arguments)})=> {eventName}?.Invoke(msg);");
                }
            }
        }

        return sb.ToString();
    }


    /// <summary>
    ///     Created on demand before each generation pass
    /// </summary>
    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public bool ShouldGenerate => (MessageToUnityTypes.Count > 0 || MessageToBlazorTypes.Count > 0) &&
                                      (UnityApiTypes.Count > 0 || BlazorApiTypes.Count > 0);

        public List<(string apiType, string namespac)> UnityApiTypes { get; } = new();
        public List<(string apiType, string namespac)> BlazorApiTypes { get; } = new();
        public List<(string messageType, string namespac)> MessageToUnityTypes { get; } = new();
        public List<(string messageType, string namespac)> MessageToBlazorTypes { get; } = new();

        /// <summary>
        ///     Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for
        ///     generation
        /// </summary>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is TypeDeclarationSyntax typeDeclarationSyntax)
            {
                var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node) as INamedTypeSymbol;

                if (symbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "UnityApiAttribute"))
                    UnityApiTypes.Add((symbol.Name, symbol.ContainingNamespace.ToDisplayString()));
                if (symbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "BlazorApiAttribute"))
                    BlazorApiTypes.Add((symbol.Name, symbol.ContainingNamespace.ToDisplayString()));
                if (symbol.AllInterfaces.Any(i => i.Name == "IMessageToUnity"))
                    MessageToUnityTypes.Add((symbol.Name, symbol.ContainingNamespace.ToDisplayString()));
                if (symbol.AllInterfaces.Any(i => i.Name == "IMessageToBlazor"))
                    MessageToBlazorTypes.Add((symbol.Name, symbol.ContainingNamespace.ToDisplayString()));
            }
        }
    }
}
@inject IJSRuntime JsRuntime
@inject Logger<BaseUnityComponent> Logger
@using System.Text
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@implements IUnityApi
@implements IDisposable

<div @ref="_containerElementReference" class="unity-container">
    <canvas id="unity-canvas" width="960" height="600" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
            <div id="unity-progress-bar-full"></div>
        </div>
    </div>
    <div id="unity-warning"> </div>
</div>

@code
{
    private IJSObjectReference? _unityApi;

    private ElementReference _containerElementReference;
    private DotNetObjectReference<JsMessageReceiverProxy>? _messageReceiverProxyReference;

    [Parameter, EditorRequired] 
    public string UnityBuildFilePath { get; set; } = "";

    public void Dispose()
    {
        _messageReceiverProxyReference?.Dispose();
    }
    
    protected override void OnInitialized()
    {
        _messageReceiverProxyReference = DotNetObjectReference.Create(new JsMessageReceiverProxy(OnMessageBytesReceived));
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }

        var moduleTask = new Lazy<Task<IJSObjectReference>>(() => JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.Unity/unityInitialization.js").AsTask());
        var module = await moduleTask.Value;

        _unityApi= await module.InvokeAsync<IJSObjectReference>("showUnity", UnityBuildFilePath, _containerElementReference, _messageReceiverProxyReference, nameof(JsMessageReceiverProxy.OnMessageBytesReceived));
        
        await base.OnAfterRenderAsync(firstRender);
    }

    public Action<byte[]> OnMessageFromUnity { get; set; }
    private void OnMessageBytesReceived(byte[] messageBytes)
    {
        OnMessageFromUnity?.Invoke(messageBytes);
    }

    public void SendMessageToUnity(byte[] messageBytes)
    {
        if (_unityApi == null)
        {
            throw new InvalidOperationException("CRITICAL FAILURE, SendMessageToUnity called without _unityApi reference!");
        }

        Task.Run(async () =>
        {
            try
            {
                await _unityApi.InvokeVoidAsync("SendMessage", messageBytes);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error sending message");
            }
        } );
    }

    private class JsMessageReceiverProxy(Action<byte[]> onMessageBytesReceived)
    {
        [JSInvokable]
        public void OnMessageBytesReceived(byte[] msg)
        {
            onMessageBytesReceived(msg);
        }
    }

}
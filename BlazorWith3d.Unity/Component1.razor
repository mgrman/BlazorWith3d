@using Microsoft.JSInterop
@inject IJSRuntime jsRuntime
@implements IDisposable

<div  @ref=ContainerElementReference class="unity-desktop">
    <canvas id="unity-canvas" width=960 height=600 tabindex="-1"></canvas>
    <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
            <div id="unity-progress-bar-full"></div>
        </div>
    </div>
    <div id="unity-warning"> </div>
    <div id="unity-footer">
        <div id="unity-logo-title-footer"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">UnityForBlazor</div>
    </div>
</div>


@code {
    private IJSObjectReference? _unityApi;

    private DotNetObjectReference<JsMessageProxy> _messageProxyReference = null!;
    
    protected ElementReference ContainerElementReference;

    protected override void OnInitialized()
    {
        
        
        _messageProxyReference = DotNetObjectReference.Create(new JsMessageProxy(OnMessageReceived, OnUnityInitialized));
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // TODO somehow the initial start via Rider does not start Unity, it gets stuck after OnBlazorApiInitialized!!! message, but reloading the page fixes the issue
        // Maybe as this is used in auto mode? it starts first with server mode, and then all async calls need to be Async!
       
        
        var moduleTask = new Lazy<Task<IJSObjectReference>>(() => jsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWith3d.Unity/exampleJsInterop.js").AsTask());

        var module = await moduleTask.Value;
        _unityApi=await module.InvokeAsync<IJSObjectReference>("showUnity", ContainerElementReference, _messageProxyReference, nameof(JsMessageProxy.OnMessageReceived), nameof(JsMessageProxy.OnUnityInitialized));

        await base.OnAfterRenderAsync(firstRender);
    }
    
    protected virtual string OnMessageReceived(string msg)
    {
        return "ACK";
    }

    protected virtual async void OnUnityInitialized()
    {
        if (_unityApi == null)
        {
            throw new InvalidOperationException("CRITICAL FAILURE, OnUnityInitialized called without _unityApi reference!");
        }
        
        var response = await _unityApi.InvokeAsync<string>("sendMessage", "test123");

        Console.WriteLine("response:" + response);
    }


    protected class JsMessageProxy(Func<string, string> onMessageReceived, Action onInitialized)
    {
        [JSInvokable]
        public string OnMessageReceived(string mesg) => onMessageReceived(mesg);

        [JSInvokable]
        public void OnUnityInitialized() => onInitialized();
    }

    public void Dispose() => _messageProxyReference?.Dispose();
}